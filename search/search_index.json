{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Please note, this content is no longer actively maintained.","text":"<p>The content of the SWC registry has not been thoroughly updated since 2020. It is known to be incomplete and may contain errors as well as crucial omissions.</p> <p>For currently maintained guidance on known Smart Contract vulnerabilities written primarily as guidance for security reviewers, please see the EEA EthTrust Security Levels specification. As well as the latest release version, an Editor's draft is available,  that represents the latest work of the group developing the specification.</p> <p>General guidance for developers on how to ensure security, that is currently maintained, is also available through the  Smart Contract Security Verification Standard (SCSVS), or the Smart Contract Security Field Guide.</p> <p>The following table contains an overview of the SWC registry. Each row consists of an SWC identifier (ID), weakness title, CWE parent and list of related code samples. The links in the ID and Test Cases columns link to the respective SWC definition. Links in the Relationships column link to the CWE Base or Class type.</p> ID Title Relationships SWC-136 Unencrypted Private Data On-Chain CWE-767: Access to Critical Private Variable via Public Method SWC-135 Code With No Effects CWE-1164: Irrelevant Code SWC-134 Message call with hardcoded gas amount CWE-655: Improper Initialization SWC-133 Hash Collisions With Multiple Variable Length Arguments CWE-294: Authentication Bypass by Capture-replay SWC-132 Unexpected Ether balance CWE-667: Improper Locking SWC-131 Presence of unused variables CWE-1164: Irrelevant Code SWC-130 Right-To-Left-Override control character (U+202E) CWE-451: User Interface (UI) Misrepresentation of Critical Information SWC-129 Typographical Error CWE-480: Use of Incorrect Operator SWC-128 DoS With Block Gas Limit CWE-400: Uncontrolled Resource Consumption SWC-127 Arbitrary Jump with Function Type Variable CWE-695: Use of Low-Level Functionality SWC-126 Insufficient Gas Griefing CWE-691: Insufficient Control Flow Management SWC-125 Incorrect Inheritance Order CWE-696: Incorrect Behavior Order SWC-124 Write to Arbitrary Storage Location CWE-123: Write-what-where Condition SWC-123 Requirement Violation CWE-573: Improper Following of Specification by Caller SWC-122 Lack of Proper Signature Verification CWE-345: Insufficient Verification of Data Authenticity SWC-121 Missing Protection against Signature Replay Attacks CWE-347: Improper Verification of Cryptographic Signature SWC-120 Weak Sources of Randomness from Chain Attributes CWE-330: Use of Insufficiently Random Values SWC-119 Shadowing State Variables CWE-710: Improper Adherence to Coding Standards SWC-118 Incorrect Constructor Name CWE-665: Improper Initialization SWC-117 Signature Malleability CWE-347: Improper Verification of Cryptographic Signature SWC-116 Block values as a proxy for time CWE-829: Inclusion of Functionality from Untrusted Control Sphere SWC-115 Authorization through tx.origin CWE-477: Use of Obsolete Function SWC-114 Transaction Order Dependence CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') SWC-113 DoS with Failed Call CWE-703: Improper Check or Handling of Exceptional Conditions SWC-112 Delegatecall to Untrusted Callee CWE-829: Inclusion of Functionality from Untrusted Control Sphere SWC-111 Use of Deprecated Solidity Functions CWE-477: Use of Obsolete Function SWC-110 Assert Violation CWE-670: Always-Incorrect Control Flow Implementation SWC-109 Uninitialized Storage Pointer CWE-824: Access of Uninitialized Pointer SWC-108 State Variable Default Visibility CWE-710: Improper Adherence to Coding Standards SWC-107 Reentrancy CWE-841: Improper Enforcement of Behavioral Workflow SWC-106 Unprotected SELFDESTRUCT Instruction CWE-284: Improper Access Control SWC-105 Unprotected Ether Withdrawal CWE-284: Improper Access Control SWC-104 Unchecked Call Return Value CWE-252: Unchecked Return Value SWC-103 Floating Pragma CWE-664: Improper Control of a Resource Through its Lifetime SWC-102 Outdated Compiler Version CWE-937: Using Components with Known Vulnerabilities SWC-101 Integer Overflow and Underflow CWE-682: Incorrect Calculation SWC-100 Function Default Visibility CWE-710: Improper Adherence to Coding Standards"},{"location":"docs/SWC-100/","title":"Please note, this content is no longer actively maintained.","text":"<p>The content of the SWC registry has not been thoroughly updated since 2020. It is known to be incomplete and may contain errors as well as crucial omissions.</p> <p>For currently maintained guidance on known Smart Contract vulnerabilities written primarily as guidance for security reviewers, please see the EEA EthTrust Security Levels specification. As well as the latest release version, an Editor's draft is available,  that represents the latest work of the group developing the specification.</p> <p>General guidance for developers on what to consider to ensure security, that is currently maintained, is also available through the  Smart Contract Security Verification Standard (SCSVS).</p>"},{"location":"docs/SWC-100/#title","title":"Title","text":"<p>Function Default Visibility</p>"},{"location":"docs/SWC-100/#relationships","title":"Relationships","text":"<ul> <li>CWE-710: Improper Adherence to Coding Standards</li> <li>EthTrust Security Levels [Q] Code Linting</li> </ul>"},{"location":"docs/SWC-100/#description","title":"Description","text":"<p>Functions that do not have a function visibility type specified are <code>public</code> by default. This can lead to a vulnerability if a developer forgot to set the visibility and a malicious user is able to make unauthorized or unintended state changes.</p>"},{"location":"docs/SWC-100/#remediation","title":"Remediation","text":"<p>Functions can be specified as being <code>external</code>, <code>public</code>, <code>internal</code> or <code>private</code>. It is recommended to make a conscious decision on which visibility type is appropriate for a function. This can dramatically reduce the attack surface of a contract system.</p>"},{"location":"docs/SWC-100/#references","title":"References","text":"<ul> <li>Ethereum Smart Contract Best Practices - Visibility</li> <li>SigmaPrime - Visibility</li> </ul>"},{"location":"docs/SWC-100/#samples","title":"Samples","text":""},{"location":"docs/SWC-100/#visibility_not_setsol","title":"visibility_not_set.sol","text":"<pre><code>/*\n * @source: https://github.com/sigp/solidity-security-blog#visibility\n * @author: SigmaPrime \n * Modified by Gerhard Wagner\n */\n\npragma solidity ^0.4.24;\n\ncontract HashForEther {\n\nfunction withdrawWinnings() {\n// Winner if the last 8 hex characters of the address are 0. \nrequire(uint32(msg.sender) == 0);\n_sendWinnings();\n}\n\nfunction _sendWinnings() {\nmsg.sender.transfer(this.balance);\n}\n}\n</code></pre>"},{"location":"docs/SWC-100/#comments","title":"Comments","text":"<p>The function declarations in lines 11 and 17 do not set the visibility of the functions. At least for Solidity 0.4.24 (as specified in the <code>pragma</code> statement), this means they will default to being treated as <code>public</code>. This allows anyone to call the <code>_sendWinings()</code> function and take the money. </p> <p>Instead, the fixed version below restricts the <code>_sendWinnings()</code> function visibility to <code>internal</code>, so it can only be activated  by the <code>WithdrawWinnings()</code> function that enforces a check whether the sender actually met the presumed conditions to receive the money.</p>"},{"location":"docs/SWC-100/#visibility_not_set_fixedsol","title":"visibility_not_set_fixed.sol","text":"<pre><code>/*\n * @source: https://github.com/sigp/solidity-security-blog#visibility\n * @author: SigmaPrime\n * Modified by Gerhard Wagner\n */\n\npragma solidity ^0.4.24;\n\ncontract HashForEther {\n\nfunction withdrawWinnings() public {\n// Winner if the last 8 hex characters of the address are 0.\nrequire(uint32(msg.sender) == 0);\n_sendWinnings();\n}\n\nfunction _sendWinnings() internal{\nmsg.sender.transfer(this.balance);\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/","title":"Title","text":"<p>Integer Overflow and Underflow</p>"},{"location":"docs/SWC-101/#relationships","title":"Relationships","text":"<p>CWE-682: Incorrect Calculation</p>"},{"location":"docs/SWC-101/#description","title":"Description","text":"<p>An overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits \u2013 either larger than the maximum or lower than the minimum representable value.</p>"},{"location":"docs/SWC-101/#remediation","title":"Remediation","text":"<p>It is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system.</p>"},{"location":"docs/SWC-101/#references","title":"References","text":"<ul> <li>Ethereum Smart Contract Best Practices - Insecure Arithmetic</li> </ul>"},{"location":"docs/SWC-101/#samples","title":"Samples","text":""},{"location":"docs/SWC-101/#tokensalechallengesol","title":"tokensalechallenge.sol","text":"<pre><code>/*\n * @source: https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\nmapping(address =&gt; uint256) public balanceOf;\nuint256 constant PRICE_PER_TOKEN = 1 ether;\n\nfunction TokenSaleChallenge(address _player) public payable {\nrequire(msg.value == 1 ether);\n}\n\nfunction isComplete() public view returns (bool) {\nreturn address(this).balance &lt; 1 ether;\n}\n\nfunction buy(uint256 numTokens) public payable {\nrequire(msg.value == numTokens * PRICE_PER_TOKEN);\n\nbalanceOf[msg.sender] += numTokens;\n}\n\nfunction sell(uint256 numTokens) public {\nrequire(balanceOf[msg.sender] &gt;= numTokens);\n\nbalanceOf[msg.sender] -= numTokens;\nmsg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_mapping_sym_1sol","title":"integer_overflow_mapping_sym_1.sol","text":"<pre><code>//Single transaction overflow\n\npragma solidity ^0.4.11;\n\ncontract IntegerOverflowMappingSym1 {\nmapping(uint256 =&gt; uint256) map;\n\nfunction init(uint256 k, uint256 v) public {\nmap[k] -= v;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_mapping_sym_1_fixedsol","title":"integer_overflow_mapping_sym_1_fixed.sol","text":"<pre><code>//Single transaction overflow\n//Safe version\n\npragma solidity ^0.4.16;\n\ncontract IntegerOverflowMappingSym1 {\nmapping(uint256 =&gt; uint256) map;\n\nfunction init(uint256 k, uint256 v) public {\nmap[k] = sub(map[k], v);\n}\n\n//from SafeMath\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b &lt;= a);//SafeMath uses assert here\nreturn a - b;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_minimalsol","title":"integer_overflow_minimal.sol","text":"<pre><code>//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\nuint public count = 1;\n\nfunction run(uint256 input) public {\ncount -= input;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_minimal_fixedsol","title":"integer_overflow_minimal_fixed.sol","text":"<pre><code>//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n//Safe version\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\nuint public count = 1;\n\nfunction run(uint256 input) public {\ncount = sub(count,input);\n}\n\n//from SafeMath\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b &lt;= a);//SafeMath uses assert here\nreturn a - b;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_mulsol","title":"integer_overflow_mul.sol","text":"<pre><code>//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMul {\nuint public count = 2;\n\nfunction run(uint256 input) public {\ncount *= input;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_mul_fixedsol","title":"integer_overflow_mul_fixed.sol","text":"<pre><code>//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n//Safe version\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMul {\nuint public count = 2;\n\nfunction run(uint256 input) public {\ncount = mul(count, input);\n}\n\n//from SafeMath\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n// benefit is lost if 'b' is also tested.\n// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\nif (a == 0) {\nreturn 0;\n}\n\nuint256 c = a * b;\nrequire(c / a == b);\n\nreturn c;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_multitx_multifunc_feasiblesol","title":"integer_overflow_multitx_multifunc_feasible.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, multi-function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\nuint256 private initialized = 0;\nuint256 public count = 1;\n\nfunction init() public {\ninitialized = 1;\n}\n\nfunction run(uint256 input) {\nif (initialized == 0) {\nreturn;\n}\n\ncount -= input;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_multitx_multifunc_feasible_fixedsol","title":"integer_overflow_multitx_multifunc_feasible_fixed.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, multi-function\n//Arithmetic instruction reachable (Safe)\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\nuint256 private initialized = 0;\nuint256 public count = 1;\n\nfunction init() public {\ninitialized = 1;\n}\n\nfunction run(uint256 input) {\nif (initialized == 0) {\nreturn;\n}\n\ncount = sub(count, input);\n}\n\n//from SafeMath\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b &lt;= a);//SafeMath uses assert here\nreturn a - b;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_multitx_onefunc_feasiblesol","title":"integer_overflow_multitx_onefunc_feasible.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, single function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\nuint256 private initialized = 0;\nuint256 public count = 1;\n\nfunction run(uint256 input) public {\nif (initialized == 0) {\ninitialized = 1;\nreturn;\n}\n\ncount -= input;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_multitx_onefunc_feasible_fixedsol","title":"integer_overflow_multitx_onefunc_feasible_fixed.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, single function\n//Arithmetic instruction reachable (Safe)\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\n\nuint256 private initialized = 0;\nuint256 public count = 1;\n\nfunction run(uint256 input) public {\nif (initialized == 0) {\ninitialized = 1;\nreturn;\n}\n\ncount = sub(count, input);\n}\n\n//from SafeMath\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b &lt;= a);//SafeMath uses assert here\nreturn a - b;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#integer_overflow_multitx_onefunc_infeasiblesol","title":"integer_overflow_multitx_onefunc_infeasible.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\n//Multi-transactional, single function\n//Overflow infeasible because arithmetic instruction not reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncInfeasible {\nuint256 private initialized = 0;\nuint256 public count = 1;\n\nfunction run(uint256 input) public {\nif (initialized == 0) {\nreturn;\n}\n\ncount -= input;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#overflow_simple_addsol","title":"overflow_simple_add.sol","text":"<pre><code>pragma solidity 0.4.24;\n\ncontract Overflow_Add {\nuint public balance = 1;\n\nfunction add(uint256 deposit) public {\nbalance += deposit;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#overflow_simple_add_fixedsol","title":"overflow_simple_add_fixed.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\ncontract Overflow_Add {\nuint public balance = 1;\n\nfunction add(uint256 deposit) public {\nbalance = add(balance, deposit);\n}\n\n//from SafeMath\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c = a + b;\nrequire(c &gt;= a);\n\nreturn c;\n}\n}\n</code></pre>"},{"location":"docs/SWC-101/#bectokensol","title":"BECToken.sol","text":"<pre><code>pragma solidity ^0.4.16;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\nfunction mul(uint256 a, uint256 b) internal constant returns (uint256) {\nuint256 c = a * b;\nrequire(a == 0 || c / a == b);\nreturn c;\n}\n\nfunction div(uint256 a, uint256 b) internal constant returns (uint256) {\n// require(b &gt; 0); // Solidity automatically throws when dividing by 0\nuint256 c = a / b;\n// require(a == b * c + a % b); // There is no case in which this doesn't hold\nreturn c;\n}\n\nfunction sub(uint256 a, uint256 b) internal constant returns (uint256) {\nrequire(b &lt;= a);\nreturn a - b;\n}\n\nfunction add(uint256 a, uint256 b) internal constant returns (uint256) {\nuint256 c = a + b;\nrequire(c &gt;= a);\nreturn c;\n}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\nuint256 public totalSupply;\nfunction balanceOf(address who) public constant returns (uint256);\nfunction transfer(address to, uint256 value) public returns (bool);\nevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\nusing SafeMath for uint256;\n\nmapping(address =&gt; uint256) balances;\n\n/**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\nfunction transfer(address _to, uint256 _value) public returns (bool) {\nrequire(_to != address(0));\nrequire(_value &gt; 0 &amp;&amp; _value &lt;= balances[msg.sender]);\n\n// SafeMath.sub will throw if there is not enough balance.\nbalances[msg.sender] = balances[msg.sender].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nTransfer(msg.sender, _to, _value);\nreturn true;\n}\n\n/**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\nfunction balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balances[_owner];\n}\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\nfunction allowance(address owner, address spender) public constant returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) public returns (bool);\nfunction approve(address spender, uint256 value) public returns (bool);\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\nmapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;\n\n\n/**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\nrequire(_to != address(0));\nrequire(_value &gt; 0 &amp;&amp; _value &lt;= balances[_from]);\nrequire(_value &lt;= allowed[_from][msg.sender]);\n\nbalances[_from] = balances[_from].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\nTransfer(_from, _to, _value);\nreturn true;\n}\n\n/**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\nfunction approve(address _spender, uint256 _value) public returns (bool) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}\n\n/**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\naddress public owner;\n\n\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n/**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\nfunction Ownable() {\nowner = msg.sender;\n}\n\n\n/**\n   * @dev Throws if called by any account other than the owner.\n   */\nmodifier onlyOwner() {\nrequire(msg.sender == owner);\n_;\n}\n\n\n/**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\nfunction transferOwnership(address newOwner) onlyOwner public {\nrequire(newOwner != address(0));\nOwnershipTransferred(owner, newOwner);\nowner = newOwner;\n}\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\nevent Pause();\nevent Unpause();\n\nbool public paused = false;\n\n\n/**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\nmodifier whenNotPaused() {\nrequire(!paused);\n_;\n}\n\n/**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\nmodifier whenPaused() {\nrequire(paused);\n_;\n}\n\n/**\n   * @dev called by the owner to pause, triggers stopped state\n   */\nfunction pause() onlyOwner whenNotPaused public {\npaused = true;\nPause();\n}\n\n/**\n   * @dev called by the owner to unpause, returns to normal state\n   */\nfunction unpause() onlyOwner whenPaused public {\npaused = false;\nUnpause();\n}\n}\n\n/**\n * @title Pausable token\n *\n * @dev StandardToken modified with pausable transfers.\n **/\n\ncontract PausableToken is StandardToken, Pausable {\n\nfunction transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\nreturn super.transfer(_to, _value);\n}\n\nfunction transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\nreturn super.transferFrom(_from, _to, _value);\n}\n\nfunction approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\nreturn super.approve(_spender, _value);\n}\n\nfunction batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\nuint cnt = _receivers.length;\nuint256 amount = uint256(cnt) * _value;\nrequire(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);\nrequire(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);\n\nbalances[msg.sender] = balances[msg.sender].sub(amount);\nfor (uint i = 0; i &lt; cnt; i++) {\nbalances[_receivers[i]] = balances[_receivers[i]].add(_value);\nTransfer(msg.sender, _receivers[i], _value);\n}\nreturn true;\n}\n}\n\n/**\n * @title Bec Token\n *\n * @dev Implementation of Bec Token based on the basic standard token.\n */\ncontract BecToken is PausableToken {\n/**\n    * Public variables of the token\n    * The following variables are OPTIONAL vanities. One does not have to include them.\n    * They allow one to customise the token contract &amp; in no way influences the core functionality.\n    * Some wallets/interfaces might not even bother to look at this information.\n    */\nstring public name = \"BeautyChain\";\nstring public symbol = \"BEC\";\nstring public version = '1.0.0';\nuint8 public decimals = 18;\n\n/**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     */\nfunction BecToken() {\ntotalSupply = 7000000000 * (10**(uint256(decimals)));\nbalances[msg.sender] = totalSupply;    // Give the creator all initial tokens\n}\n\nfunction () {\n//if ether is sent to this address, send it back.\nrevert();\n}\n}\n</code></pre>"},{"location":"docs/SWC-102/","title":"Please note, this content is no longer actively maintained.","text":"<p>The content of the SWC registry has not been thoroughly updated since 2020. It is known to be incomplete and may contain errors as well as crucial omissions.</p> <p>For currently maintained guidance on known Smart Contract vulnerabilities written primarily as guidance for security reviewers, please see the EEA EthTrust Security Levels specification. As well as the latest release version, an Editor's draft is available,  that represents the latest work of the group developing the specification.</p> <p>General guidance for developers on what to consider to ensure security, that is currently maintained, is also available through the  Smart Contract Security Verification Standard (SCSVS).</p>"},{"location":"docs/SWC-102/#title","title":"Title","text":"<p>Outdated Compiler Version</p>"},{"location":"docs/SWC-102/#relationships","title":"Relationships","text":"<p>CWE-937: Using Components with Known Vulnerabilities</p>"},{"location":"docs/SWC-102/#description","title":"Description","text":"<p>Using an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.</p>"},{"location":"docs/SWC-102/#remediation","title":"Remediation","text":"<p>It is recommended to use a recent version of the Solidity compiler.</p>"},{"location":"docs/SWC-102/#references","title":"References","text":"<ul> <li>Solidity Release Notes</li> <li>Etherscan Solidity Bug Info</li> <li>EEA EthTrust Security Levels:</li> <li>Level [S] Compiler Security Bugs</li> <li>Level [S] Improved Compilers</li> <li>Level [M] Compiler Bugs and Overriding Requirements</li> <li>Recommended Practice Use the Latest Compiler</li> </ul>"},{"location":"docs/SWC-102/#samples","title":"Samples","text":""},{"location":"docs/SWC-102/#version_0_4_13sol","title":"version_0_4_13.sol","text":"<pre><code>pragma solidity 0.4.13;\n\ncontract OutdatedCompilerVersion {\nuint public x = 1;\n}\n</code></pre>"},{"location":"docs/SWC-102/#comments","title":"Comments","text":"<p>As of August 2023 the current version of the compiler is 0.8.21. There are several dozen compiler bugs that have been fixed between that and version 0.4.13, each of which can lead to data being corrupted, contracts not functioning as expected, or unexpected vulnerabilities in contracts.  There have also been significant improvements in compiler capabilities to protect against errors.</p> <p>See also the sections Level [S] Compiler Security Bugs, Level [S] Improved Compilers, and Level [M] Compiler Bugs and Overriding Requirements</p>"},{"location":"docs/SWC-103/","title":"Title","text":"<p>Floating Pragma</p>"},{"location":"docs/SWC-103/#relationships","title":"Relationships","text":"<p>CWE-664: Improper Control of a Resource Through its Lifetime</p>"},{"location":"docs/SWC-103/#description","title":"Description","text":"<p>Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.</p>"},{"location":"docs/SWC-103/#remediation","title":"Remediation","text":"<p>Lock the pragma version and also consider known bugs (https://github.com/ethereum/solidity/releases) for the compiler version that is chosen.</p> <p>Pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.</p>"},{"location":"docs/SWC-103/#references","title":"References","text":"<ul> <li>Ethereum Smart Contract Best Practices - Locking Pragmas</li> </ul>"},{"location":"docs/SWC-103/#samples","title":"Samples","text":""},{"location":"docs/SWC-103/#floating_pragmasol","title":"floating_pragma.sol","text":"<pre><code>pragma solidity ^0.4.0;\n\ncontract PragmaNotLocked {\nuint public x = 1;\n}\n</code></pre>"},{"location":"docs/SWC-103/#floating_pragma_fixedsol","title":"floating_pragma_fixed.sol","text":"<pre><code>pragma solidity 0.4.25;\n\ncontract PragmaFixed {\nuint public x = 1;\n}\n</code></pre>"},{"location":"docs/SWC-103/#no_pragmasol","title":"no_pragma.sol","text":"<pre><code>contract PragmaNotLocked {\nuint public x = 1;\n}\n</code></pre>"},{"location":"docs/SWC-103/#semver_floating_pragmasol","title":"semver_floating_pragma.sol","text":"<pre><code>pragma solidity &gt;=0.4.0 &lt; 0.6.0;\npragma solidity &gt;=0.4.0&lt;0.6.0;\npragma solidity &gt;=0.4.14 &lt;0.6.0;\npragma solidity &gt;0.4.13 &lt;0.6.0;\npragma solidity 0.4.24 - 0.5.2;\npragma solidity &gt;=0.4.24 &lt;=0.5.3 ~0.4.20;\npragma solidity &lt;0.4.26;\npragma solidity ~0.4.20;\npragma solidity ^0.4.14;\npragma solidity 0.4.*;\npragma solidity 0.*;\npragma solidity *;\npragma solidity 0.4;\npragma solidity 0;\n\ncontract SemVerFloatingPragma {\n}\n</code></pre>"},{"location":"docs/SWC-103/#semver_floating_pragma_fixedsol","title":"semver_floating_pragma_fixed.sol","text":"<pre><code>pragma solidity 0.4.25;\n// or\npragma solidity =0.4.25;\n\ncontract SemVerFloatingPragmaFixed {\n}\n</code></pre>"},{"location":"docs/SWC-104/","title":"Title","text":"<p>Unchecked Call Return Value</p>"},{"location":"docs/SWC-104/#relationships","title":"Relationships","text":"<p>CWE-252: Unchecked Return Value</p>"},{"location":"docs/SWC-104/#description","title":"Description","text":"<p>The return value of a message call is not checked. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.</p>"},{"location":"docs/SWC-104/#remediation","title":"Remediation","text":"<p>If you choose to use low-level call methods, make sure to handle the possibility that the call will fail by checking the return value.</p>"},{"location":"docs/SWC-104/#references","title":"References","text":"<ul> <li>Ethereum Smart Contract Best Practices - Handle errors in external calls</li> </ul>"},{"location":"docs/SWC-104/#samples","title":"Samples","text":""},{"location":"docs/SWC-104/#unchecked_return_valuesol","title":"unchecked_return_value.sol","text":"<pre><code>pragma solidity 0.4.25;\n\ncontract ReturnValue {\n\nfunction callchecked(address callee) public {\nrequire(callee.call());\n}\n\nfunction callnotchecked(address callee) public {\ncallee.call();\n}\n}\n</code></pre>"},{"location":"docs/SWC-105/","title":"Title","text":"<p>Unprotected Ether Withdrawal</p>"},{"location":"docs/SWC-105/#relationships","title":"Relationships","text":"<p>CWE-284: Improper Access Control</p>"},{"location":"docs/SWC-105/#description","title":"Description","text":"<p>Due to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.</p> <p>This bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime byte code and can be called by anyone to re-initialize the contract.</p>"},{"location":"docs/SWC-105/#remediation","title":"Remediation","text":"<p>Implement controls so withdrawals can only be triggered by authorized parties or according to the specs of the smart contract system.</p>"},{"location":"docs/SWC-105/#references","title":"References","text":"<ul> <li>Rubixi smart contract</li> </ul>"},{"location":"docs/SWC-105/#samples","title":"Samples","text":""},{"location":"docs/SWC-105/#tokensalechallengesol","title":"tokensalechallenge.sol","text":"<pre><code>/*\n * @source: https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\nmapping(address =&gt; uint256) public balanceOf;\nuint256 constant PRICE_PER_TOKEN = 1 ether;\n\nfunction TokenSaleChallenge(address _player) public payable {\nrequire(msg.value == 1 ether);\n}\n\nfunction isComplete() public view returns (bool) {\nreturn address(this).balance &lt; 1 ether;\n}\n\nfunction buy(uint256 numTokens) public payable {\nrequire(msg.value == numTokens * PRICE_PER_TOKEN);\n\nbalanceOf[msg.sender] += numTokens;\n}\n\nfunction sell(uint256 numTokens) public {\nrequire(balanceOf[msg.sender] &gt;= numTokens);\n\nbalanceOf[msg.sender] -= numTokens;\nmsg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n}\n}\n</code></pre>"},{"location":"docs/SWC-105/#rubixisol","title":"rubixi.sol","text":"<pre><code>pragma solidity ^0.4.22;\n\ncontract Rubixi {\n\n//Declare variables for storage critical to contract\nuint private balance = 0;\nuint private collectedFees = 0;\nuint private feePercent = 10;\nuint private pyramidMultiplier = 300;\nuint private payoutOrder = 0;\n\naddress private creator;\n\n//Sets creator\nfunction DynamicPyramid() {\ncreator = msg.sender;\n}\n\nmodifier onlyowner {\nif (msg.sender == creator) _;\n}\n\nstruct Participant {\naddress etherAddress;\nuint payout;\n}\n\nParticipant[] private participants;\n\n//Fallback function\nfunction() {\ninit();\n}\n\n//init function run on fallback\nfunction init() private {\n//Ensures only tx with value of 1 ether or greater are processed and added to pyramid\nif (msg.value &lt; 1 ether) {\ncollectedFees += msg.value;\nreturn;\n}\n\nuint _fee = feePercent;\n//50% fee rebate on any ether value of 50 or greater\nif (msg.value &gt;= 50 ether) _fee /= 2;\n\naddPayout(_fee);\n}\n\n//Function called for valid tx to the contract\nfunction addPayout(uint _fee) private {\n//Adds new address to participant array\nparticipants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n//These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\nif (participants.length == 10) pyramidMultiplier = 200;\nelse if (participants.length == 25) pyramidMultiplier = 150;\n\n// collect fees and update contract balance\nbalance += (msg.value * (100 - _fee)) / 100;\ncollectedFees += (msg.value * _fee) / 100;\n\n//Pays earlier participiants if balance sufficient\nwhile (balance &gt; participants[payoutOrder].payout) {\nuint payoutToSend = participants[payoutOrder].payout;\nparticipants[payoutOrder].etherAddress.send(payoutToSend);\n\nbalance -= participants[payoutOrder].payout;\npayoutOrder += 1;\n}\n}\n\n//Fee functions for creator\nfunction collectAllFees() onlyowner {\nif (collectedFees == 0) throw;\n\ncreator.send(collectedFees);\ncollectedFees = 0;\n}\n\nfunction collectFeesInEther(uint _amt) onlyowner {\n_amt *= 1 ether;\nif (_amt &gt; collectedFees) collectAllFees();\n\nif (collectedFees == 0) throw;\n\ncreator.send(_amt);\ncollectedFees -= _amt;\n}\n\nfunction collectPercentOfFees(uint _pcent) onlyowner {\nif (collectedFees == 0 || _pcent &gt; 100) throw;\n\nuint feesToCollect = collectedFees / 100 * _pcent;\ncreator.send(feesToCollect);\ncollectedFees -= feesToCollect;\n}\n\n//Functions for changing variables related to the contract\nfunction changeOwner(address _owner) onlyowner {\ncreator = _owner;\n}\n\nfunction changeMultiplier(uint _mult) onlyowner {\nif (_mult &gt; 300 || _mult &lt; 120) throw;\n\npyramidMultiplier = _mult;\n}\n\nfunction changeFeePercentage(uint _fee) onlyowner {\nif (_fee &gt; 10) throw;\n\nfeePercent = _fee;\n}\n\n//Functions to provide information to end-user using JSON interface or other interfaces\nfunction currentMultiplier() constant returns(uint multiplier, string info) {\nmultiplier = pyramidMultiplier;\ninfo = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n}\n\nfunction currentFeePercentage() constant returns(uint fee, string info) {\nfee = feePercent;\ninfo = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n}\n\nfunction currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\npyramidBalance = balance / 1 ether;\ninfo = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n}\n\nfunction nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\nbalancePayout = participants[payoutOrder].payout / 1 ether;\n}\n\nfunction feesSeperateFromBalanceApproximately() constant returns(uint fees) {\nfees = collectedFees / 1 ether;\n}\n\nfunction totalParticipants() constant returns(uint count) {\ncount = participants.length;\n}\n\nfunction numberOfParticipantsWaitingForPayout() constant returns(uint count) {\ncount = participants.length - payoutOrder;\n}\n\nfunction participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\nif (orderInPyramid &lt;= participants.length) {\nAddress = participants[orderInPyramid].etherAddress;\nPayout = participants[orderInPyramid].payout / 1 ether;\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-105/#multiowned_not_vulnerablesol","title":"multiowned_not_vulnerable.sol","text":"<pre><code>pragma solidity ^0.4.23;\n\n/**\n * @title MultiOwnable\n */\ncontract MultiOwnable {\naddress public root;\nmapping (address =&gt; address) public owners; // owner =&gt; parent of owner\n\n/**\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n  * account.\n  */\nconstructor() public {\nroot = msg.sender;\nowners[root] = root;\n}\n\n/**\n  * @dev Throws if called by any account other than the owner.\n  */\nmodifier onlyOwner() {\nrequire(owners[msg.sender] != 0);\n_;\n}\n\n/**\n  * @dev Adding new owners\n  * Note that the \"onlyOwner\" modifier is used here.\n  */ function newOwner(address _owner) onlyOwner external returns (bool) {\nrequire(_owner != 0);\nowners[_owner] = msg.sender;\nreturn true;\n}\n\n/**\n    * @dev Deleting owners\n    */\nfunction deleteOwner(address _owner) onlyOwner external returns (bool) {\nrequire(owners[_owner] == msg.sender || (owners[_owner] != 0 &amp;&amp; msg.sender == root));\nowners[_owner] = 0;\nreturn true;\n}\n}\n\ncontract TestContract is MultiOwnable {\n\nfunction withdrawAll() onlyOwner {\nmsg.sender.transfer(this.balance);\n}\n\nfunction() payable {\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-105/#multiowned_vulnerablesol","title":"multiowned_vulnerable.sol","text":"<pre><code>pragma solidity ^0.4.23;\n\n/**\n * @title MultiOwnable\n */\ncontract MultiOwnable {\naddress public root;\nmapping (address =&gt; address) public owners; // owner =&gt; parent of owner\n\n/**\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n  * account.\n  */\nconstructor() public {\nroot = msg.sender;\nowners[root] = root;\n}\n\n/**\n  * @dev Throws if called by any account other than the owner.\n  */\nmodifier onlyOwner() {\nrequire(owners[msg.sender] != 0);\n_;\n}\n\n/**\n  * @dev Adding new owners\n  * Note that the \"onlyOwner\" modifier is missing here.\n  */ function newOwner(address _owner) external returns (bool) {\nrequire(_owner != 0);\nowners[_owner] = msg.sender;\nreturn true;\n}\n\n/**\n    * @dev Deleting owners\n    */\nfunction deleteOwner(address _owner) onlyOwner external returns (bool) {\nrequire(owners[_owner] == msg.sender || (owners[_owner] != 0 &amp;&amp; msg.sender == root));\nowners[_owner] = 0;\nreturn true;\n}\n}\n\ncontract TestContract is MultiOwnable {\n\nfunction withdrawAll() onlyOwner {\nmsg.sender.transfer(this.balance);\n}\n\nfunction() payable {\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-105/#simple_ether_drainsol","title":"simple_ether_drain.sol","text":"<pre><code>pragma solidity ^0.4.22;\n\ncontract SimpleEtherDrain {\n\nfunction withdrawAllAnyone() {\nmsg.sender.transfer(this.balance);\n}\n\nfunction () public payable {\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-105/#wallet_01_oksol","title":"wallet_01_ok.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\n/* User can add pay in and withdraw Ether.\n   Nobody can withdraw more Ether than they paid in.\n*/\n\ncontract Wallet {\naddress creator;\n\nmapping(address =&gt; uint256) balances;\n\nconstructor() public {\ncreator = msg.sender;\n}\n\nfunction deposit() public payable {\nassert(balances[msg.sender] + msg.value &gt; balances[msg.sender]);\nbalances[msg.sender] += msg.value;\n}\n\nfunction withdraw(uint256 amount) public {\nrequire(amount &lt;= balances[msg.sender]);\nmsg.sender.transfer(amount);\nbalances[msg.sender] -= amount;\n}\n\nfunction refund() public {\nmsg.sender.transfer(balances[msg.sender]);\nbalances[msg.sender] = 0;\n}\n\n// In an emergency the owner can migrate  allfunds to a different address.\n\nfunction migrateTo(address to) public {\nrequire(creator == msg.sender);\nto.transfer(this.balance);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-105/#wallet_02_refund_nosubsol","title":"wallet_02_refund_nosub.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\n/* User can add pay in and withdraw Ether.\n   Unfortunately the developer forgot set the user's balance to 0 when refund() is called.\n   An attacker can pay in a small amount of Ether and call refund() repeatedly to empty the contract.\n*/\n\ncontract Wallet {\naddress creator;\n\nmapping(address =&gt; uint256) balances;\n\nconstructor() public {\ncreator = msg.sender;\n}\n\nfunction deposit() public payable {\nassert(balances[msg.sender] + msg.value &gt; balances[msg.sender]);\nbalances[msg.sender] += msg.value;\n}\n\nfunction withdraw(uint256 amount) public {\nrequire(amount &lt;= balances[msg.sender]);\nmsg.sender.transfer(amount);\nbalances[msg.sender] -= amount;\n}\n\nfunction refund() public {\nmsg.sender.transfer(balances[msg.sender]);\n}\n\n// In an emergency the owner can migrate  allfunds to a different address.\n\nfunction migrateTo(address to) public {\nrequire(creator == msg.sender);\nto.transfer(this.balance);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-105/#wallet_03_wrong_constructorsol","title":"wallet_03_wrong_constructor.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\n/* User can add pay in and withdraw Ether.\n   The constructor is wrongly named, so anyone can become 'creator' and withdraw all funds.\n*/\n\ncontract Wallet {\naddress creator;\n\nmapping(address =&gt; uint256) balances;\n\nfunction initWallet() public {\ncreator = msg.sender;\n}\n\nfunction deposit() public payable {\nassert(balances[msg.sender] + msg.value &gt; balances[msg.sender]);\nbalances[msg.sender] += msg.value;\n}\n\nfunction withdraw(uint256 amount) public {\nrequire(amount &lt;= balances[msg.sender]);\nmsg.sender.transfer(amount);\nbalances[msg.sender] -= amount;\n}\n\n// In an emergency the owner can migrate  allfunds to a different address.\n\nfunction migrateTo(address to) public {\nrequire(creator == msg.sender);\nto.transfer(this.balance);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-105/#wallet_04_confused_signsol","title":"wallet_04_confused_sign.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\n/* User can add pay in and withdraw Ether.\n   Unfortunatelty, the developer was drunk and used the wrong comparison operator in \"withdraw()\"\n   Anybody can withdraw arbitrary amounts of Ether :()\n*/\n\ncontract Wallet {\naddress creator;\n\nmapping(address =&gt; uint256) balances;\n\nconstructor() public {\ncreator = msg.sender;\n}\n\nfunction deposit() public payable {\nassert(balances[msg.sender] + msg.value &gt; balances[msg.sender]);\nbalances[msg.sender] += msg.value;\n}\n\nfunction withdraw(uint256 amount) public {\nrequire(amount &gt;= balances[msg.sender]);\nmsg.sender.transfer(amount);\nbalances[msg.sender] -= amount;\n}\n\n// In an emergency the owner can migrate  allfunds to a different address.\n\nfunction migrateTo(address to) public {\nrequire(creator == msg.sender);\nto.transfer(this.balance);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-106/","title":"Title","text":"<p>Unprotected SELFDESTRUCT Instruction</p>"},{"location":"docs/SWC-106/#relationships","title":"Relationships","text":"<p>CWE-284: Improper Access Control</p>"},{"location":"docs/SWC-106/#description","title":"Description","text":"<p>Due to missing or insufficient access controls, malicious parties can self-destruct the contract.</p>"},{"location":"docs/SWC-106/#remediation","title":"Remediation","text":"<p>Consider removing the self-destruct functionality unless it is absolutely required. If there is a valid use-case, it is recommended to implement a multisig scheme so that multiple parties must approve the self-destruct action.</p>"},{"location":"docs/SWC-106/#references","title":"References","text":"<ul> <li>Parity \"I accidentally killed it\" bug</li> </ul>"},{"location":"docs/SWC-106/#samples","title":"Samples","text":""},{"location":"docs/SWC-106/#walletlibrarysol","title":"WalletLibrary.sol","text":"<pre><code>//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood &lt;g@ethdev.com&gt;\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n// EVENTS\n\n// this contract only has six types of events: it can accept a confirmation, in which case\n// we record owner and operation (hash) alongside it.\nevent Confirmation(address owner, bytes32 operation);\nevent Revoke(address owner, bytes32 operation);\n\n// some others are in the case of an owner changing.\nevent OwnerChanged(address oldOwner, address newOwner);\nevent OwnerAdded(address newOwner);\nevent OwnerRemoved(address oldOwner);\n\n// the last one is emitted if the required signatures change\nevent RequirementChanged(uint newRequirement);\n\n// Funds has arrived into the wallet (record how much).\nevent Deposit(address _from, uint value);\n// Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\nevent SingleTransact(address owner, uint value, address to, bytes data, address created);\n// Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\nevent MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\n// Confirmation still needed for a transaction.\nevent ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\n\ncontract WalletAbi {\n// Revokes a prior confirmation of the given operation\nfunction revoke(bytes32 _operation) external;\n\n// Replaces an owner `_from` with another `_to`.\nfunction changeOwner(address _from, address _to) external;\n\nfunction addOwner(address _owner) external;\n\nfunction removeOwner(address _owner) external;\n\nfunction changeRequirement(uint _newRequired) external;\n\nfunction isOwner(address _addr) constant returns (bool);\n\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\n\n// (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\nfunction setDailyLimit(uint _newLimit) external;\n\nfunction execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\nfunction confirm(bytes32 _h) returns (bool o_success);\n}\n\ncontract WalletLibrary is WalletEvents {\n// TYPES\n\n// struct for the status of a pending operation.\nstruct PendingState {\nuint yetNeeded;\nuint ownersDone;\nuint index;\n}\n\n// Transaction structure to remember details of transaction lest it need be saved for a later call.\nstruct Transaction {\naddress to;\nuint value;\nbytes data;\n}\n\n// MODIFIERS\n\n// simple single-sig function modifier.\nmodifier onlyowner {\nif (isOwner(msg.sender))\n_;\n}\n// multi-sig function modifier: the operation must have an intrinsic hash in order\n// that later attempts can be realised as the same underlying operation and\n// thus count as confirmations.\nmodifier onlymanyowners(bytes32 _operation) {\nif (confirmAndCheck(_operation))\n_;\n}\n\n// METHODS\n\n// gets called when no other function matches\nfunction() payable {\n// just being sent some cash?\nif (msg.value &gt; 0)\nDeposit(msg.sender, msg.value);\n}\n\n// constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n// as well as the selection of addresses capable of confirming them.\nfunction initMultiowned(address[] _owners, uint _required) only_uninitialized {\nm_numOwners = _owners.length + 1;\nm_owners[1] = uint(msg.sender);\nm_ownerIndex[uint(msg.sender)] = 1;\nfor (uint i = 0; i &lt; _owners.length; ++i)\n{\nm_owners[2 + i] = uint(_owners[i]);\nm_ownerIndex[uint(_owners[i])] = 2 + i;\n}\nm_required = _required;\n}\n\n// Revokes a prior confirmation of the given operation\nfunction revoke(bytes32 _operation) external {\nuint ownerIndex = m_ownerIndex[uint(msg.sender)];\n// make sure they're an owner\nif (ownerIndex == 0) return;\nuint ownerIndexBit = 2**ownerIndex;\nvar pending = m_pending[_operation];\nif (pending.ownersDone &amp; ownerIndexBit &gt; 0) {\npending.yetNeeded++;\npending.ownersDone -= ownerIndexBit;\nRevoke(msg.sender, _operation);\n}\n}\n\n// Replaces an owner `_from` with another `_to`.\nfunction changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\nif (isOwner(_to)) return;\nuint ownerIndex = m_ownerIndex[uint(_from)];\nif (ownerIndex == 0) return;\n\nclearPending();\nm_owners[ownerIndex] = uint(_to);\nm_ownerIndex[uint(_from)] = 0;\nm_ownerIndex[uint(_to)] = ownerIndex;\nOwnerChanged(_from, _to);\n}\n\nfunction addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\nif (isOwner(_owner)) return;\n\nclearPending();\nif (m_numOwners &gt;= c_maxOwners)\nreorganizeOwners();\nif (m_numOwners &gt;= c_maxOwners)\nreturn;\nm_numOwners++;\nm_owners[m_numOwners] = uint(_owner);\nm_ownerIndex[uint(_owner)] = m_numOwners;\nOwnerAdded(_owner);\n}\n\nfunction removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\nuint ownerIndex = m_ownerIndex[uint(_owner)];\nif (ownerIndex == 0) return;\nif (m_required &gt; m_numOwners - 1) return;\n\nm_owners[ownerIndex] = 0;\nm_ownerIndex[uint(_owner)] = 0;\nclearPending();\nreorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\nOwnerRemoved(_owner);\n}\n\nfunction changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\nif (_newRequired &gt; m_numOwners) return;\nm_required = _newRequired;\nclearPending();\nRequirementChanged(_newRequired);\n}\n\n// Gets an owner by 0-indexed position (using numOwners as the count)\nfunction getOwner(uint ownerIndex) external constant returns (address) {\nreturn address(m_owners[ownerIndex + 1]);\n}\n\nfunction isOwner(address _addr) constant returns (bool) {\nreturn m_ownerIndex[uint(_addr)] &gt; 0;\n}\n\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\nvar pending = m_pending[_operation];\nuint ownerIndex = m_ownerIndex[uint(_owner)];\n\n// make sure they're an owner\nif (ownerIndex == 0) return false;\n\n// determine the bit to set for this owner.\nuint ownerIndexBit = 2**ownerIndex;\nreturn !(pending.ownersDone &amp; ownerIndexBit == 0);\n}\n\n// constructor - stores initial daily limit and records the present day's index.\nfunction initDaylimit(uint _limit) only_uninitialized {\nm_dailyLimit = _limit;\nm_lastDay = today();\n}\n// (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\nfunction setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\nm_dailyLimit = _newLimit;\n}\n// resets the amount already spent today. needs many of the owners to confirm.\nfunction resetSpentToday() onlymanyowners(sha3(msg.data)) external {\nm_spentToday = 0;\n}\n\n// throw unless the contract is not yet initialized.\nmodifier only_uninitialized { if (m_numOwners &gt; 0) throw; _; }\n\n// constructor - just pass on the owner array to the multiowned and\n// the limit to daylimit\nfunction initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {\ninitDaylimit(_daylimit);\ninitMultiowned(_owners, _required);\n}\n\n// kills the contract sending everything to `_to`.\nfunction kill(address _to) onlymanyowners(sha3(msg.data)) external {\nsuicide(_to);\n}\n\n// Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n// If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n// shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n// and _data arguments). They still get the option of using them if they want, anyways.\nfunction execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\n// first, take the opportunity to check that we're under the daily limit.\nif ((_data.length == 0 &amp;&amp; underLimit(_value)) || m_required == 1) {\n// yes - just execute the call.\naddress created;\nif (_to == 0) {\ncreated = create(_value, _data);\n} else {\nif (!_to.call.value(_value)(_data))\nthrow;\n}\nSingleTransact(msg.sender, _value, _to, _data, created);\n} else {\n// determine our operation hash.\no_hash = sha3(msg.data, block.number);\n// store if it's new\nif (m_txs[o_hash].to == 0 &amp;&amp; m_txs[o_hash].value == 0 &amp;&amp; m_txs[o_hash].data.length == 0) {\nm_txs[o_hash].to = _to;\nm_txs[o_hash].value = _value;\nm_txs[o_hash].data = _data;\n}\nif (!confirm(o_hash)) {\nConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n}\n}\n}\n\nfunction create(uint _value, bytes _code) internal returns (address o_addr) {\n/*\n    assembly {\n      o_addr := create(_value, add(_code, 0x20), mload(_code))\n      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n    }\n    */\n}\n\n// confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n// to determine the body of the transaction from the hash provided.\nfunction confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\nif (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\naddress created;\nif (m_txs[_h].to == 0) {\ncreated = create(m_txs[_h].value, m_txs[_h].data);\n} else {\nif (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\nthrow;\n}\n\nMultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\ndelete m_txs[_h];\nreturn true;\n}\n}\n\n// INTERNAL METHODS\n\nfunction confirmAndCheck(bytes32 _operation) internal returns (bool) {\n// determine what index the present sender is:\nuint ownerIndex = m_ownerIndex[uint(msg.sender)];\n// make sure they're an owner\nif (ownerIndex == 0) return;\n\nvar pending = m_pending[_operation];\n// if we're not yet working on this operation, switch over and reset the confirmation status.\nif (pending.yetNeeded == 0) {\n// reset count of confirmations needed.\npending.yetNeeded = m_required;\n// reset which owners have confirmed (none) - set our bitmap to 0.\npending.ownersDone = 0;\npending.index = m_pendingIndex.length++;\nm_pendingIndex[pending.index] = _operation;\n}\n// determine the bit to set for this owner.\nuint ownerIndexBit = 2**ownerIndex;\n// make sure we (the message sender) haven't confirmed this operation previously.\nif (pending.ownersDone &amp; ownerIndexBit == 0) {\nConfirmation(msg.sender, _operation);\n// ok - check if count is enough to go ahead.\nif (pending.yetNeeded &lt;= 1) {\n// enough confirmations: reset and run interior.\ndelete m_pendingIndex[m_pending[_operation].index];\ndelete m_pending[_operation];\nreturn true;\n}\nelse\n{\n// not enough: record that this owner in particular confirmed.\npending.yetNeeded--;\npending.ownersDone |= ownerIndexBit;\n}\n}\n}\n\nfunction reorganizeOwners() private {\nuint free = 1;\nwhile (free &lt; m_numOwners)\n{\nwhile (free &lt; m_numOwners &amp;&amp; m_owners[free] != 0) free++;\nwhile (m_numOwners &gt; 1 &amp;&amp; m_owners[m_numOwners] == 0) m_numOwners--;\nif (free &lt; m_numOwners &amp;&amp; m_owners[m_numOwners] != 0 &amp;&amp; m_owners[free] == 0)\n{\nm_owners[free] = m_owners[m_numOwners];\nm_ownerIndex[m_owners[free]] = free;\nm_owners[m_numOwners] = 0;\n}\n}\n}\n\n// checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n// returns true. otherwise just returns false.\nfunction underLimit(uint _value) internal onlyowner returns (bool) {\n// reset the spend limit if we're on a different day to last time.\nif (today() &gt; m_lastDay) {\nm_spentToday = 0;\nm_lastDay = today();\n}\n// check to see if there's enough left - if so, subtract and return true.\n// overflow protection                    // dailyLimit check\nif (m_spentToday + _value &gt;= m_spentToday &amp;&amp; m_spentToday + _value &lt;= m_dailyLimit) {\nm_spentToday += _value;\nreturn true;\n}\nreturn false;\n}\n\n// determines today's index.\nfunction today() private constant returns (uint) { return now / 1 days; }\n\nfunction clearPending() internal {\nuint length = m_pendingIndex.length;\n\nfor (uint i = 0; i &lt; length; ++i) {\ndelete m_txs[m_pendingIndex[i]];\n\nif (m_pendingIndex[i] != 0)\ndelete m_pending[m_pendingIndex[i]];\n}\n\ndelete m_pendingIndex;\n}\n\n// FIELDS\naddress constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n// the number of owners that must confirm the same operation before it is run.\nuint public m_required;\n// pointer used to find a free slot in m_owners\nuint public m_numOwners;\n\nuint public m_dailyLimit;\nuint public m_spentToday;\nuint public m_lastDay;\n\n// list of owners\nuint[256] m_owners;\n\nuint constant c_maxOwners = 250;\n// index on the list of owners to allow reverse lookup\nmapping(uint =&gt; uint) m_ownerIndex;\n// the ongoing operations.\nmapping(bytes32 =&gt; PendingState) m_pending;\nbytes32[] m_pendingIndex;\n\n// pending transactions we have at present.\nmapping (bytes32 =&gt; Transaction) m_txs;\n}\n</code></pre>"},{"location":"docs/SWC-106/#simple_suicidesol","title":"simple_suicide.sol","text":"<pre><code>pragma solidity ^0.4.22;\n\ncontract SimpleSuicide {\n\nfunction sudicideAnyone() {\nselfdestruct(msg.sender);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-106/#suicide_multitx_feasiblesol","title":"suicide_multitx_feasible.sol","text":"<pre><code>pragma solidity ^0.4.23;\n\ncontract SuicideMultiTxFeasible {\nuint256 private initialized = 0;\nuint256 public count = 1;\n\nfunction init() public {\ninitialized = 1;\n}\n\nfunction run(uint256 input) {\nif (initialized == 0) {\nreturn;\n}\n\nselfdestruct(msg.sender);\n}\n}\n</code></pre>"},{"location":"docs/SWC-106/#suicide_multitx_infeasiblesol","title":"suicide_multitx_infeasible.sol","text":"<pre><code>pragma solidity ^0.4.23;\n\ncontract SuicideMultiTxFeasible {\nuint256 private initialized = 0;\nuint256 public count = 1;\n\nfunction init() public {\ninitialized = 1;\n}\n\nfunction run(uint256 input) {\nif (initialized != 2) {\nreturn;\n}\n\nselfdestruct(msg.sender);\n}\n}\n</code></pre>"},{"location":"docs/SWC-107/","title":"Title","text":"<p>Reentrancy</p>"},{"location":"docs/SWC-107/#relationships","title":"Relationships","text":"<p>CWE-841: Improper Enforcement of Behavioral Workflow</p>"},{"location":"docs/SWC-107/#description","title":"Description","text":"<p>One of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.</p>"},{"location":"docs/SWC-107/#remediation","title":"Remediation","text":"<p>The best practices to avoid Reentrancy weaknesses are:</p> <ul> <li>Make sure all internal state changes are performed before the call is executed. This is known as the Checks-Effects-Interactions pattern</li> <li>Use a reentrancy lock (ie.  OpenZeppelin's ReentrancyGuard).</li> </ul>"},{"location":"docs/SWC-107/#references","title":"References","text":"<ul> <li>Ethereum Smart Contract Best Practices - Reentrancy</li> </ul>"},{"location":"docs/SWC-107/#samples","title":"Samples","text":""},{"location":"docs/SWC-107/#modifier_reentrancysol","title":"modifier_reentrancy.sol","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract ModifierEntrancy {\n\nmapping (address =&gt; uint) public tokenBalance;\nstring constant name = \"Nu Token\";\nBank bank;\n\nconstructor() public{\nbank = new Bank();\n}\n\n//If a contract has a zero balance and supports the token give them some token\nfunction airDrop() hasNoBalance supportsToken  public{\ntokenBalance[msg.sender] += 20;\n}\n\n//Checks that the contract responds the way we want\nmodifier supportsToken() {\nrequire(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());\n_;\n}\n\n//Checks that the caller has a zero balance\nmodifier hasNoBalance {\nrequire(tokenBalance[msg.sender] == 0);\n_;\n}\n}\n\ncontract Bank{\n\nfunction supportsToken() external returns(bytes32) {\nreturn keccak256(abi.encodePacked(\"Nu Token\"));\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-107/#modifier_reentrancy_fixedsol","title":"modifier_reentrancy_fixed.sol","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract ModifierEntrancy {\nmapping (address =&gt; uint) public tokenBalance;\nstring constant name = \"Nu Token\";\nBank bank;\nconstructor() public{\nbank = new Bank();\n}\n\n//If a contract has a zero balance and supports the token give them some token\nfunction airDrop() supportsToken hasNoBalance  public{ // In the fixed version supportsToken comes before hasNoBalance\ntokenBalance[msg.sender] += 20;\n}\n\n//Checks that the contract responds the way we want\nmodifier supportsToken() {\nrequire(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());\n_;\n}\n//Checks that the caller has a zero balance\nmodifier hasNoBalance {\nrequire(tokenBalance[msg.sender] == 0);\n_;\n}\n}\n\ncontract Bank{\n\nfunction supportsToken() external returns(bytes32){\nreturn(keccak256(abi.encodePacked(\"Nu Token\")));\n}\n}\n</code></pre>"},{"location":"docs/SWC-107/#simple_daosol","title":"simple_dao.sol","text":"<pre><code>/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: Atzei N., Bartoletti M., Cimoli T\n * Modified by Josselin Feist\n */\npragma solidity 0.4.24;\n\ncontract SimpleDAO {\nmapping (address =&gt; uint) public credit;\n\nfunction donate(address to) payable public{\ncredit[to] += msg.value;\n}\n\nfunction withdraw(uint amount) public{\nif (credit[msg.sender]&gt;= amount) {\nrequire(msg.sender.call.value(amount)());\ncredit[msg.sender]-=amount;\n}\n}  function queryCredit(address to) view public returns(uint){\nreturn credit[to];\n}\n}\n</code></pre>"},{"location":"docs/SWC-107/#simple_dao_fixedsol","title":"simple_dao_fixed.sol","text":"<pre><code>/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: Atzei N., Bartoletti M., Cimoli T\n * Modified by Bernhard Mueller, Josselin Feist\n */\npragma solidity 0.4.24;\n\ncontract SimpleDAO {\nmapping (address =&gt; uint) public credit;\n\nfunction donate(address to) payable public{\ncredit[to] += msg.value;\n}\n\nfunction withdraw(uint amount) public {\nif (credit[msg.sender]&gt;= amount) {\ncredit[msg.sender]-=amount;\nrequire(msg.sender.call.value(amount)());\n}\n}  function queryCredit(address to) view public returns (uint){\nreturn credit[to];\n}\n}\n</code></pre>"},{"location":"docs/SWC-108/","title":"Title","text":"<p>State Variable Default Visibility</p>"},{"location":"docs/SWC-108/#relationships","title":"Relationships","text":"<p>CWE-710: Improper Adherence to Coding Standards</p>"},{"location":"docs/SWC-108/#description","title":"Description","text":"<p>Labeling the visibility explicitly makes it easier to catch incorrect assumptions about who can access the variable.</p>"},{"location":"docs/SWC-108/#remediation","title":"Remediation","text":"<p>Variables can be specified as being <code>public</code>, <code>internal</code> or <code>private</code>. Explicitly define visibility for all state variables.</p>"},{"location":"docs/SWC-108/#references","title":"References","text":"<ul> <li>Ethereum Smart Contract Best Practices - Visibility</li> </ul>"},{"location":"docs/SWC-108/#samples","title":"Samples","text":""},{"location":"docs/SWC-108/#storagesol","title":"storage.sol","text":"<pre><code>pragma solidity 0.4.24;\n\ncontract TestStorage {\n\nuint storeduint1 = 15;\nuint constant constuint = 16;\nuint32 investmentsDeadlineTimeStamp = uint32(now); bytes16 string1 = \"test1\"; bytes32 private string2 = \"test1236\"; string public string3 = \"lets string something\"; mapping (address =&gt; uint) public uints1; mapping (address =&gt; DeviceData) structs1; uint[] uintarray; DeviceData[] deviceDataArray; struct DeviceData {\nstring deviceBrand;\nstring deviceYear;\nstring batteryWearLevel;\n}\n\nfunction testStorage() public  {\naddress address1 = 0xbccc714d56bc0da0fd33d96d2a87b680dd6d0df6;\naddress address2 = 0xaee905fdd3ed851e48d22059575b9f4245a82b04;\n\nuints1[address1] = 88;\nuints1[address2] = 99;\n\nDeviceData memory dev1 = DeviceData(\"deviceBrand\", \"deviceYear\", \"wearLevel\");\n\nstructs1[address1] = dev1;\n\nuintarray.push(8000);\nuintarray.push(9000);\n\ndeviceDataArray.push(dev1);\n}\n}\n</code></pre>"},{"location":"docs/SWC-109/","title":"Title","text":"<p>Uninitialized Storage Pointer</p>"},{"location":"docs/SWC-109/#relationships","title":"Relationships","text":"<p>CWE-824: Access of Uninitialized Pointer</p>"},{"location":"docs/SWC-109/#description","title":"Description","text":"<p>Uninitialized local storage variables can point to unexpected storage locations in the contract, which can lead to intentional or unintentional vulnerabilities.</p>"},{"location":"docs/SWC-109/#remediation","title":"Remediation","text":"<p>Check if the contract requires a storage object as in many situations this is actually not the case. If a local variable is sufficient, mark the storage location of the variable explicitly with the <code>memory</code> attribute. If a storage variable is needed then initialise it upon declaration and additionally specify the storage location <code>storage</code>.</p> <p>Note: As of compiler version 0.5.0 and higher this issue has been systematically resolved as contracts with uninitialised storage pointers do no longer compile.</p>"},{"location":"docs/SWC-109/#references","title":"References","text":"<ul> <li>SigmaPrime - Uninitialised Storage Pointers</li> </ul>"},{"location":"docs/SWC-109/#samples","title":"Samples","text":""},{"location":"docs/SWC-109/#crypto_roulettesol","title":"crypto_roulette.sol","text":"<pre><code>/*\n * @source: https://github.com/thec00n/smart-contract-honeypots/blob/master/CryptoRoulette.sol\n */\npragma solidity ^0.4.19;\n\n// CryptoRoulette\n//\n// Guess the number secretly stored in the blockchain and win the whole contract balance!\n// A new number is randomly chosen after each try.\n//\n// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether\n\ncontract CryptoRoulette {\n\nuint256 private secretNumber;\nuint256 public lastPlayed;\nuint256 public betPrice = 0.1 ether;\naddress public ownerAddr;\n\nstruct Game {\naddress player;\nuint256 number;\n}\nGame[] public gamesPlayed;\n\nfunction CryptoRoulette() public {\nownerAddr = msg.sender;\nshuffle();\n}\n\nfunction shuffle() internal {\n// randomly set secretNumber with a value between 1 and 20\nsecretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;\n}\n\nfunction play(uint256 number) payable public {\nrequire(msg.value &gt;= betPrice &amp;&amp; number &lt;= 10);\n\nGame game;\ngame.player = msg.sender;\ngame.number = number;\ngamesPlayed.push(game);\n\nif (number == secretNumber) {\n// win!\nmsg.sender.transfer(this.balance);\n}\n\nshuffle();\nlastPlayed = now;\n}\n\nfunction kill() public {\nif (msg.sender == ownerAddr &amp;&amp; now &gt; lastPlayed + 1 days) {\nsuicide(msg.sender);\n}\n}\n\nfunction() public payable { }\n}\n</code></pre>"},{"location":"docs/SWC-109/#crypto_roulette_fixedsol","title":"crypto_roulette_fixed.sol","text":"<pre><code>/*\n * @source: https://github.com/thec00n/smart-contract-honeypots/blob/master/CryptoRoulette.sol\n */\npragma solidity ^0.4.19;\n\n// CryptoRoulette\n//\n// Guess the number secretly stored in the blockchain and win the whole contract balance!\n// A new number is randomly chosen after each try.\n//\n// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether\n\ncontract CryptoRoulette {\n\nuint256 private secretNumber;\nuint256 public lastPlayed;\nuint256 public betPrice = 0.1 ether;\naddress public ownerAddr;\n\nstruct Game {\naddress player;\nuint256 number;\n}\nGame[] public gamesPlayed;\n\nfunction CryptoRoulette() public {\nownerAddr = msg.sender;\nshuffle();\n}\n\nfunction shuffle() internal {\n// randomly set secretNumber with a value between 1 and 20\nsecretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;\n}\n\nfunction play(uint256 number) payable public {\nrequire(msg.value &gt;= betPrice &amp;&amp; number &lt;= 10);\n\nGame memory game;\ngame.player = msg.sender;\ngame.number = number;\ngamesPlayed.push(game);\n\nif (number == secretNumber) {\n// win!\nmsg.sender.transfer(this.balance);\n}\n\nshuffle();\nlastPlayed = now;\n}\n\nfunction kill() public {\nif (msg.sender == ownerAddr &amp;&amp; now &gt; lastPlayed + 1 days) {\nsuicide(msg.sender);\n}\n}\n\nfunction() public payable { }\n}\n</code></pre>"},{"location":"docs/SWC-110/","title":"Title","text":"<p>Assert Violation</p>"},{"location":"docs/SWC-110/#relationships","title":"Relationships","text":"<p>CWE-670: Always-Incorrect Control Flow Implementation</p>"},{"location":"docs/SWC-110/#description","title":"Description","text":"<p>The Solidity <code>assert()</code> function is meant to assert invariants. Properly functioning code should never reach a failing assert statement. A reachable assertion can mean one of two things:</p> <ol> <li>A bug exists in the contract that allows it to enter an invalid state;</li> <li>The <code>assert</code> statement is used incorrectly, e.g. to validate inputs.</li> </ol>"},{"location":"docs/SWC-110/#remediation","title":"Remediation","text":"<p>Consider whether the condition checked in the <code>assert()</code> is actually an invariant. If not, replace the <code>assert()</code> statement with a <code>require()</code> statement.</p> <p>If the exception is indeed caused by unexpected behaviour of the code, fix the underlying bug(s) that allow the assertion to be violated.</p>"},{"location":"docs/SWC-110/#references","title":"References","text":"<ul> <li>The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the EVM</li> </ul>"},{"location":"docs/SWC-110/#samples","title":"Samples","text":""},{"location":"docs/SWC-110/#assert_constructorsol","title":"assert_constructor.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\npragma solidity ^0.4.19;\n\ncontract AssertConstructor {\nfunction AssertConstructor() public {\nassert(false);\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#assert_minimalsol","title":"assert_minimal.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\npragma solidity ^0.4.19;\n\ncontract AssertMinimal {\nfunction run() public {\nassert(false);\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#assert_multitx_1sol","title":"assert_multitx_1.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\npragma solidity ^0.4.19;\n\ncontract AssertMultiTx1 {\nuint256 private param;\n\nfunction AssertMultiTx1(uint256 _param) public {\nrequire(_param &gt; 0);\nparam = _param;\n}\n\nfunction run() {\nassert(param &gt; 0);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-110/#assert_multitx_2sol","title":"assert_multitx_2.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\npragma solidity ^0.4.19;\n\ncontract AssertMultiTx2 {\nuint256 private param;\n\nfunction AssertMultiTx2(uint256 _param) public {\nparam = 0;\n}\n\nfunction run() {\nassert(param &gt; 0);\n}\n\nfunction set(uint256 _param) {\nparam = _param;\n}\n\n\n}\n</code></pre>"},{"location":"docs/SWC-110/#constructor_createsol","title":"constructor_create.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\n\npragma solidity ^0.4.25;\n\ncontract ConstructorCreate{\nB b = new B();\n\nfunction check(){\nassert(b.foo() == 10);\n}\n\n}\n\ncontract B{\n\nfunction foo() returns(uint){\nreturn 11;\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#constructor_create_argumentsol","title":"constructor_create_argument.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.22;\n\ncontract ConstructorCreateArgument{\nB b = new B(11);\n\nfunction check(){\nassert(b.foo() == 10);\n}\n\n}\n\ncontract B{\n\nuint x_;\nconstructor(uint x){\nx_ = x;\n}\n\nfunction foo() returns(uint){\nreturn x_;\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#constructor_create_modifiablesol","title":"constructor_create_modifiable.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n * Assert violation with 2 message calls:\n * - B.set_x(X): X != 10\n * - ContructorCreateModifiable.check()\n */\n\npragma solidity ^0.4.22;\n\ncontract ContructorCreateModifiable{\nB b = new B(10);\n\nfunction check(){\nassert(b.foo() == 10);\n}\n\n}\n\ncontract B{\n\nuint x_;\nconstructor(uint x){\nx_ = x;\n}\n\nfunction foo() returns(uint){\nreturn x_;\n}\n\nfunction set_x(uint x){\nx_ = x;\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#gas_modelsol","title":"gas_model.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.21;\n\ncontract GasModel{\nuint x = 100;\nfunction check(){\nuint a = gasleft();\nx = x + 1;\nuint b = gasleft();\nassert(b &gt; a);\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#gas_model_fixedsol","title":"gas_model_fixed.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.21;\n\ncontract GasModelFixed{\nuint x = 100;\nfunction check(){\nuint a = gasleft();\nx = x + 1;\nuint b = gasleft();\nassert(b &lt; a);\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#mapping_perfomance_2sol","title":"mapping_perfomance_2.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.22;\n\ncontract MappingPerformance2sets{\n\nmapping(bytes32=&gt;uint) m0;\nmapping(bytes32=&gt;uint) m1;\nmapping(bytes32=&gt;uint) m2;\nmapping(bytes32=&gt;uint) m3;\nmapping(bytes32=&gt;uint) m4;\nmapping(bytes32=&gt;uint) m5;\nuint b;\n\nconstructor(){\nb = 10;\n}\n\nfunction set(bytes32 a, uint cond){\nif(cond == 0){\nm0[a] = 5;\n}else if(cond == 1){\nm1[a] = 5;\n}else if(cond == 2){\nm2[a] = 5;\n}else if(cond == 3){\nm3[a] = 5;\n}else if(cond == 4){\nm4[a] = 5;\n}\n}\nfunction check(bytes32 a0, uint cond0,\nbytes32 a1, uint cond1, bytes32 a){\nset(a0, cond0);\nset(a1, cond1);\nassert(m5[a] == 0);\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#mapping_performance_1sol","title":"mapping_performance_1.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.22;\n\ncontract MappingPerformance1set{\n\nmapping(bytes32=&gt;uint) m0;\nmapping(bytes32=&gt;uint) m1;\nmapping(bytes32=&gt;uint) m2;\nmapping(bytes32=&gt;uint) m3;\nmapping(bytes32=&gt;uint) m4;\nmapping(bytes32=&gt;uint) m5;\nuint b;\n\nconstructor(){\nb = 10;\n}\n\nfunction set(bytes32 a, uint cond){\nif(cond == 0){\nm0[a] = 5;\n}else if(cond == 1){\nm1[a] = 5;\n}else if(cond == 2){\nm2[a] = 5;\n}else if(cond == 3){\nm3[a] = 5;\n}else if(cond == 4){\nm4[a] = 5;\n}\n}\nfunction check(bytes32 a0, uint cond0, bytes32 a){\nset(a0, cond0);\nassert(m5[a] == 0);\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#out-of-bounds-exceptionsol","title":"out-of-bounds-exception.sol","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract OutOfBoundsException {\n\nuint256[] private array;\n\nfunction getArrayElement(uint256 idx) public returns (uint256) {\nreturn array[idx];\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-110/#return_memorysol","title":"return_memory.sol","text":"<pre><code>/*\n * @source: https://forum.zeppelin.solutions/t/using-automatic-analysis-tools-with-makerdao-contracts/1021/3\n * Author: Dan Guido / Trail of Bits\n * Slightly modified by Bernhard Mueller\n\n* An assertion violation is possible in 3 transactions:\n*\n* etch(addr)\n* lookup(slate, addr)\n* checkAnInvariant()\n\n* Whereby slate == Keccak(addr)\n*\n* Ideally tools should output the correct transaction trace.\n*/\n\npragma solidity ^0.5.0;\n\ncontract ReturnMemory {\nmapping(bytes32=&gt;address) public slates;\nbool everMatched = false;\n\nfunction etch(address yay) public returns (bytes32 slate) {\nbytes32 hash = keccak256(abi.encodePacked(yay));\nslates[hash] = yay;\nreturn hash;\n}\n\nfunction lookup(bytes32 slate, address nay) public {\nif (nay != address(0x0)) {\neverMatched = slates[slate] == nay;\n}\n}\n\nfunction checkAnInvariant() public returns (bool) {\nassert(!everMatched);\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#runtime_create_user_inputsol","title":"runtime_create_user_input.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.22;\n\ncontract RuntimeCreateUserInput{\n\nfunction check(uint x){\nB b = new B(x);\nassert(b.foo() == 10);\n}\n\n}\n\ncontract B{\n\nuint x_;\nconstructor(uint x){\nx_ = x;\n}\n\nfunction foo() returns(uint){\nreturn x_;\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-110/#runtime_user_input_callsol","title":"runtime_user_input_call.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.19;\n\ncontract RuntimeUserInputCall{\n\nfunction check(address b){\nassert(B(b).foo() == 10);\n}\n\n}\n\ncontract B{\nfunction foo() returns(uint);\n}\n</code></pre>"},{"location":"docs/SWC-110/#sha_of_sha_2_mappingssol","title":"sha_of_sha_2_mappings.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.22;\n\ncontract ShaOfSha2Mappings{\n\nmapping(bytes32=&gt;uint) m;\nmapping(bytes32=&gt;uint) n;\n\nconstructor(){\nm[keccak256(abi.encode(\"AAA\", msg.sender))] = 100;\n}\n\nfunction check(address a){\nassert(n[keccak256(abi.encode(\"BBB\", a))] == 0);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-110/#sha_of_sha_collisionsol","title":"sha_of_sha_collision.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n * Assert violation with 2 message calls:\n * - set(66)\n * - check(0x4100000000000000000000000000000000000000000000000000000000000000)\n */\npragma solidity ^0.4.22;\n\ncontract ShaOfShaCollission{\n\nmapping(bytes32=&gt;uint) m;\n\nfunction set(uint x){\nm[keccak256(abi.encodePacked(\"A\", x))] = 1;\n}\nfunction check(uint x){\nassert(m[keccak256(abi.encodePacked(x, \"B\"))] == 0);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-110/#sha_of_sha_concretesol","title":"sha_of_sha_concrete.sol","text":"<pre><code>/*\n * @source: ChainSecurity\n * @author: Anton Permenev\n */\npragma solidity ^0.4.22;\n\ncontract ShaOfShaConcrete{\n\nmapping(bytes32=&gt;uint) m;\nuint b;\n\nconstructor(){\nb = 1;\n}\n\nfunction check(uint x){\nassert(m[keccak256(abi.encodePacked(x, \"B\"))] == 0);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-110/#token-with-backdoorsol","title":"token-with-backdoor.sol","text":"<pre><code>/*\n * @source: TrailofBits workshop at TruffleCon 2018\n * @author: Josselin Feist (adapted for SWC by Bernhard Mueller)\n * Assert violation with 3 message calls:\n * - airdrop()\n * - backdoor()\n * - test_invariants()\n */\npragma solidity ^0.4.22;\n\ncontract Token{\n\nmapping(address =&gt; uint) public balances;\nfunction airdrop() public{\nbalances[msg.sender] = 1000;\n}\n\nfunction consume() public{\nrequire(balances[msg.sender]&gt;0);\nbalances[msg.sender] -= 1;\n}\n\nfunction backdoor() public{\nbalances[msg.sender] += 1;\n}\n\nfunction test_invariants() {\nassert(balances[msg.sender] &lt;= 1000);\n}\n}\n</code></pre>"},{"location":"docs/SWC-110/#two_mapppingssol","title":"two_mapppings.sol","text":"<pre><code>pragma solidity ^0.4.22;\n\ncontract TwoMappings{\n\nmapping(uint=&gt;uint) m;\nmapping(uint=&gt;uint) n;\n\nconstructor(){\nm[10] = 100;\n}\n\nfunction check(uint a){\nassert(n[a] == 0);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-110/#simpledschiefsol","title":"simpledschief.sol","text":"<pre><code>/*\n * @source: https://forum.zeppelin.solutions/t/using-automatic-analysis-tools-with-makerdao-contracts/1021/3\n * Author: Vera Bogdanich Espina / Zeppelin Solutions\n *\n * A simplified version of the MakerDAO DSChief contract.\n*  Tools should output the correct transaction trace (see source link).\n*/\n\ncontract SimpleDSChief {\nmapping(bytes32=&gt;address) public slates;\nmapping(address=&gt;bytes32) public votes;\nmapping(address=&gt;uint256) public approvals;\nmapping(address=&gt;uint256) public deposits;\n\nfunction lock(uint wad) public {\ndeposits[msg.sender] = add(deposits[msg.sender], wad);\naddWeight(wad, votes[msg.sender]);\n}\n\nfunction free(uint wad) public {\ndeposits[msg.sender] = sub(deposits[msg.sender], wad);\nsubWeight(wad, votes[msg.sender]);\n}\n\nfunction voteYays(address yay) public returns (bytes32){\nbytes32 slate = etch(yay);\nvoteSlate(slate);\n\nreturn slate;\n}\n\nfunction etch(address yay) public returns (bytes32 slate) {\nbytes32 hash = keccak256(abi.encodePacked(yay));\n\nslates[hash] = yay;\n\nreturn hash;\n}\n\nfunction voteSlate(bytes32 slate) public {\nuint weight = deposits[msg.sender];\nsubWeight(weight, votes[msg.sender]);\nvotes[msg.sender] = slate;\naddWeight(weight, votes[msg.sender]);\n}\n\nfunction addWeight(uint weight, bytes32 slate) internal {\naddress yay = slates[slate];\napprovals[yay] = add(approvals[yay], weight);\n}\n\nfunction subWeight(uint weight, bytes32 slate) internal {\naddress yay = slates[slate];\napprovals[yay] = sub(approvals[yay], weight);\n}\n\nfunction add(uint x, uint y) internal pure returns (uint z) {\nrequire((z = x + y) &gt;= x);\n}\n\nfunction sub(uint x, uint y) internal pure returns (uint z) {\nrequire((z = x - y) &lt;= x);\n}\n\nfunction checkAnInvariant() public {\nbytes32 senderSlate = votes[msg.sender];\naddress option = slates[senderSlate];\nuint256 senderDeposit = deposits[msg.sender];\n\nassert(approvals[option] &gt;= senderDeposit);\n}\n}\n</code></pre>"},{"location":"docs/SWC-111/","title":"Title","text":"<p>Use of Deprecated Solidity Functions</p>"},{"location":"docs/SWC-111/#relationships","title":"Relationships","text":"<p>CWE-477: Use of Obsolete Function</p>"},{"location":"docs/SWC-111/#description","title":"Description","text":"<p>Several functions and operators in Solidity are deprecated. Using them leads to reduced code quality. With new major versions of the Solidity compiler, deprecated functions and operators may result in side effects and compile errors.</p>"},{"location":"docs/SWC-111/#remediation","title":"Remediation","text":"<p>Solidity provides alternatives to the deprecated constructions. Most of them are aliases, thus replacing old constructions will not break current behavior. For example, <code>sha3</code> can be replaced with <code>keccak256</code>.</p> Deprecated Alternative <code>suicide(address)</code> <code>selfdestruct(address)</code> <code>block.blockhash(uint)</code> <code>blockhash(uint)</code> <code>sha3(...)</code> <code>keccak256(...)</code> <code>callcode(...)</code> <code>delegatecall(...)</code> <code>throw</code> <code>revert()</code> <code>msg.gas</code> <code>gasleft</code> <code>constant</code> <code>view</code> <code>var</code> corresponding type name"},{"location":"docs/SWC-111/#references","title":"References","text":"<ul> <li>List of global variables and functions, as of Solidity 0.4.25</li> <li>Error handling: Assert, Require, Revert and Exceptions</li> <li>View functions</li> <li>Untyped declaration is deprecated as of Solidity 0.4.20</li> <li>Solidity compiler changelog</li> </ul>"},{"location":"docs/SWC-111/#samples","title":"Samples","text":""},{"location":"docs/SWC-111/#deprecated_simplesol","title":"deprecated_simple.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\ncontract DeprecatedSimple {\n\n// Do everything that's deprecated, then commit suicide.\n\nfunction useDeprecated() public constant {\n\nbytes32 blockhash = block.blockhash(0);\nbytes32 hashofhash = sha3(blockhash);\n\nuint gas = msg.gas;\n\nif (gas == 0) {\nthrow;\n}\n\naddress(this).callcode();\n\nvar a = [1,2,3];\n\nvar (x, y, z) = (false, \"test\", 0);\n\nsuicide(address(0));\n}\n\nfunction () public {}\n\n}\n</code></pre>"},{"location":"docs/SWC-111/#deprecated_simple_fixedsol","title":"deprecated_simple_fixed.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\ncontract DeprecatedSimpleFixed {\n\nfunction useDeprecatedFixed() public view {\n\nbytes32 bhash = blockhash(0);\nbytes32 hashofhash = keccak256(bhash);\n\nuint gas = gasleft();\n\nif (gas == 0) {\nrevert();\n}\n\naddress(this).delegatecall();\n\nuint8[3] memory a = [1,2,3];\n\n(bool x, string memory y, uint8 z) = (false, \"test\", 0);\n\nselfdestruct(address(0));\n}\n\nfunction () external {}\n\n}\n</code></pre>"},{"location":"docs/SWC-112/","title":"Title","text":"<p>Delegatecall to Untrusted Callee</p>"},{"location":"docs/SWC-112/#relationships","title":"Relationships","text":"<p>CWE-829: Inclusion of Functionality from Untrusted Control Sphere</p>"},{"location":"docs/SWC-112/#description","title":"Description","text":"<p>There exists a special variant of a message call, named <code>delegatecall</code> which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and <code>msg.sender</code> and <code>msg.value</code> do not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.</p> <p>Calling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.</p>"},{"location":"docs/SWC-112/#remediation","title":"Remediation","text":"<p>Use <code>delegatecall</code> with caution and make sure to never call into untrusted contracts. If the target address is derived from user input ensure to check it against a whitelist of trusted contracts.</p>"},{"location":"docs/SWC-112/#references","title":"References","text":"<ul> <li>Solidity Documentation - Delegatecall / Callcode and Libraries</li> <li>How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1) - Delegate Call</li> <li>Solidity Security: Comprehensive list of known attack vectors and common anti-patterns - Delegatecall</li> </ul>"},{"location":"docs/SWC-112/#samples","title":"Samples","text":""},{"location":"docs/SWC-112/#proxysol","title":"proxy.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\ncontract Proxy {\n\naddress owner;\n\nconstructor() public {\nowner = msg.sender;  }\n\nfunction forward(address callee, bytes _data) public {\nrequire(callee.delegatecall(_data));\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-112/#proxy_fixedsol","title":"proxy_fixed.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\ncontract Proxy {\n\naddress callee;\naddress owner;\n\nmodifier onlyOwner {\nrequire(msg.sender == owner);\n_;\n}\n\nconstructor() public {\ncallee = address(0x0);\nowner = msg.sender;\n}\n\nfunction setCallee(address newCallee) public onlyOwner {\ncallee = newCallee;\n}\n\nfunction forward(bytes _data) public {\nrequire(callee.delegatecall(_data));\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-112/#proxy_pattern_false_positivesol","title":"proxy_pattern_false_positive.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\ncontract proxy{\naddress owner;\n\nfunction proxyCall(address _to, bytes _data) external {\nrequire( !_to.delegatecall(_data));\n}\nfunction withdraw() external{\nrequire(msg.sender == owner);\nmsg.sender.transfer(address(this).balance);\n}\n} /*\nYou can't use proxyCall to change the owner address as either: \n\n1) the delegatecall reverts and thus does not change owner\n2) the delegatecall does not revert and therefore will cause the proxyCall to revert and preventing owner from changing\n\nThis false positive may seem like a really edge case, however since you can revert data back to proxy this patern is useful for proxy architectures\n*/\n</code></pre>"},{"location":"docs/SWC-113/","title":"Title","text":"<p>DoS with Failed Call</p>"},{"location":"docs/SWC-113/#relationships","title":"Relationships","text":"<p>CWE-703: Improper Check or Handling of Exceptional Conditions</p>"},{"location":"docs/SWC-113/#description","title":"Description","text":"<p>External calls can fail accidentally or deliberately, which can cause a DoS condition in the contract. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).</p>"},{"location":"docs/SWC-113/#remediation","title":"Remediation","text":"<p>It is recommended to follow call best practices:</p> <ul> <li>Avoid combining multiple calls in a single transaction, especially when calls are executed as part of a loop</li> <li>Always assume that external calls can fail</li> <li>Implement the contract logic to handle failed calls</li> </ul>"},{"location":"docs/SWC-113/#references","title":"References","text":"<ul> <li>Ethereum Smart Contract Best Practices - Favor pull over push for external calls</li> </ul>"},{"location":"docs/SWC-113/#samples","title":"Samples","text":""},{"location":"docs/SWC-113/#send_loopsol","title":"send_loop.sol","text":"<pre><code>/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert\n * @author: ConsenSys Diligence\n * Modified by Bernhard Mueller\n */\n\npragma solidity 0.4.24;\n\ncontract Refunder {\n\naddress[] private refundAddresses;\nmapping (address =&gt; uint) public refunds;\n\nconstructor() {\nrefundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);\nrefundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n}\n\n// bad\nfunction refundAll() public {\nfor(uint x; x &lt; refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated\nrequire(refundAddresses[x].send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds\n}\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-114/","title":"Title","text":"<p>Transaction Order Dependence</p>"},{"location":"docs/SWC-114/#relationships","title":"Relationships","text":"<p>CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')</p>"},{"location":"docs/SWC-114/#description","title":"Description","text":"<p>The Ethereum network processes transactions in blocks, with new blocks getting confirmed approximately every 17 seconds. Miners review the transactions they have received and select which ones to include in a block, based on who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network, they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized. A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.</p> <p>The simplest example of a race condition is when a smart contract gives a reward for submitting information. Suppose a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So, Eve submits the answer to the network with a much higher gas price, and thus it gets processed and committed before Alice's transaction. Eve receives one token, and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor's deposit to the person who proved they were misbehaving.</p> <p>The race condition that happens most frequently on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called 'approve', which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve's approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs an Ethereum node, so she knows that Alice is going to change her approval to m. Eve then submits a transferFrom request, sending n of Alice's tokens to herself, but gives it a much higher gas price than Alice's transaction. The transferFrom executes first so gives Eve n tokens and sets Eve's approval to zero. Then Alice's transaction executes and sets Eve's approval to m. Eve then sends those m tokens to herself as well. Thus, Eve gets n + m tokens, even though she should have gotten at most max(n,m).</p>"},{"location":"docs/SWC-114/#remediation","title":"Remediation","text":"<p>A possible way to remedy race conditions in the submission of information in exchange for a reward is called a commit reveal hash scheme. Instead of submitting the answer, the party who has the answer submits hash(salt, address, answer) [salt being some number of their choosing]; the contract stores this hash and the sender's address. To claim the reward, the sender then submits a transaction with the salt, and answer. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash. If the hash matches, the contract releases the reward.</p> <p>The best fix for the ERC20 race condition is to add a field to the inputs of approve, which is the expected current value, and to have approve revert if Eve's current allowance is not what Alice indicated she was expecting. However, this means that your contract no longer conforms to the ERC20 standard. If it is important to your project to have the contract conform to ERC20, you can add a safe approve function. From the user's perspective, it is possible to mitigate the ERC20 race condition by setting approvals to zero before changing them.</p>"},{"location":"docs/SWC-114/#references","title":"References","text":"<p>General Article on Race Conditions ERC20 Race Condition</p>"},{"location":"docs/SWC-114/#samples","title":"Samples","text":""},{"location":"docs/SWC-114/#erc20sol","title":"ERC20.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\n/** Taken from the OpenZeppelin github\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n/**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n// benefit is lost if 'b' is also tested.\n// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\nif (a == 0) {\nreturn 0;\n}\n\nuint256 c = a * b;\nrequire(c / a == b);\n\nreturn c;\n}\n\n/**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b &gt; 0); // Solidity only automatically asserts when dividing by 0\nuint256 c = a / b;\n// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\nreturn c;\n}\n\n/**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b &lt;= a);\nuint256 c = a - b;\n\nreturn c;\n}\n\n/**\n  * @dev Adds two numbers, reverts on overflow.\n  */\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c = a + b;\nrequire(c &gt;= a);\n\nreturn c;\n}\n\n/**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b != 0);\nreturn a % b;\n}\n}\n\n\ncontract ERC20 {\n\nevent Transfer( address indexed from, address indexed to, uint256 value );\nevent Approval( address indexed owner, address indexed spender, uint256 value);\nusing SafeMath for *;\n\nmapping (address =&gt; uint256) private _balances;\n\nmapping (address =&gt; mapping (address =&gt; uint256)) private _allowed;\n\nuint256 private _totalSupply;\n\nconstructor(uint totalSupply){\n_balances[msg.sender] = totalSupply;\n}\n\nfunction balanceOf(address owner) public view returns (uint256) {\nreturn _balances[owner];\n}\n\n\nfunction allowance(address owner, address spender) public view returns (uint256)\n{\nreturn _allowed[owner][spender];\n}\n\nfunction transfer(address to, uint256 value) public returns (bool) {\nrequire(value &lt;= _balances[msg.sender]);\nrequire(to != address(0));\n\n_balances[msg.sender] = _balances[msg.sender].sub(value);\n_balances[to] = _balances[to].add(value);\nemit Transfer(msg.sender, to, value);\nreturn true;\n}\n\nfunction approve(address spender, uint256 value) public returns (bool) {\nrequire(spender != address(0));\n\n_allowed[msg.sender][spender] = value;\nemit Approval(msg.sender, spender, value);\nreturn true;\n}\n\nfunction transferFrom(address from, address to, uint256 value) public returns (bool) {\nrequire(value &lt;= _balances[from]);\nrequire(value &lt;= _allowed[from][msg.sender]);\nrequire(to != address(0));\n\n_balances[from] = _balances[from].sub(value);\n_balances[to] = _balances[to].add(value);\n_allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\nemit Transfer(from, to, value);\nreturn true;\n}\n}\n</code></pre>"},{"location":"docs/SWC-114/#eth_tx_order_dependence_minimalsol","title":"eth_tx_order_dependence_minimal.sol","text":"<pre><code>/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n */\n\npragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\naddress public owner;\nbool public claimed;\nuint public reward;\n\nfunction EthTxOrderDependenceMinimal() public {\nowner = msg.sender;\n}\n\nfunction setReward() public payable {\nrequire (!claimed);\n\nrequire(msg.sender == owner);\nowner.transfer(reward);\nreward = msg.value;\n}\n\nfunction claimReward(uint256 submission) {\nrequire (!claimed);\nrequire(submission &lt; 10);\n\nmsg.sender.transfer(reward);\nclaimed = true;\n}\n}\n</code></pre>"},{"location":"docs/SWC-115/","title":"Title","text":"<p>Authorization through tx.origin</p>"},{"location":"docs/SWC-115/#relationships","title":"Relationships","text":"<p>CWE-477: Use of Obsolete Function</p>"},{"location":"docs/SWC-115/#description","title":"Description","text":"<p><code>tx.origin</code> is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since <code>tx.origin</code> returns the original sender of the transaction which in this case is the authorized account.</p>"},{"location":"docs/SWC-115/#remediation","title":"Remediation","text":"<p><code>tx.origin</code> should not be used for authorization. Use <code>msg.sender</code> instead.</p>"},{"location":"docs/SWC-115/#references","title":"References","text":"<ul> <li>Solidity Documentation - tx.origin</li> <li>Ethereum Smart Contract Best Practices - Avoid using tx.origin</li> <li>SigmaPrime - Visibility</li> </ul>"},{"location":"docs/SWC-115/#samples","title":"Samples","text":""},{"location":"docs/SWC-115/#mycontractsol","title":"mycontract.sol","text":"<pre><code>/*\n * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin\n * @author: Consensys Diligence  \n * Modified by Gerhard Wagner\n */\n\npragma solidity 0.4.24;\n\ncontract MyContract {\n\naddress owner;\n\nfunction MyContract() public {\nowner = msg.sender;\n}\n\nfunction sendTo(address receiver, uint amount) public {\nrequire(tx.origin == owner);\nreceiver.transfer(amount);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-115/#mycontract_fixedsol","title":"mycontract_fixed.sol","text":"<pre><code>/*\n * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin\n * @author: Consensys Diligence\n * Modified by Gerhard Wagner\n */\n\npragma solidity 0.4.25;\n\ncontract MyContract {\n\naddress owner;\n\nfunction MyContract() public {\nowner = msg.sender;\n}\n\nfunction sendTo(address receiver, uint amount) public {\nrequire(msg.sender == owner);\nreceiver.transfer(amount);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-116/","title":"Title","text":"<p>Block values as a proxy for time</p>"},{"location":"docs/SWC-116/#relationships","title":"Relationships","text":"<p>CWE-829: Inclusion of Functionality from Untrusted Control Sphere</p>"},{"location":"docs/SWC-116/#description","title":"Description","text":"<p>Contracts often need access to time values to perform certain types of functionality. Values such as <code>block.timestamp</code>, and <code>block.number</code> can give you a sense of the current time or a time delta, however, they are not safe to use for most purposes.</p> <p>In the case of <code>block.timestamp</code>, developers often attempt to use it to trigger time-dependent events. As Ethereum is decentralized, nodes can synchronize time only to some degree. Moreover, malicious miners can alter the timestamp of their blocks, especially if they can gain advantages by doing so. However, miners can't set a timestamp smaller than the previous one (otherwise the block will be rejected), nor can they set the timestamp too far ahead in the future. Taking all of the above into consideration, developers can't rely on the preciseness of the provided timestamp.</p> <p>As for <code>block.number</code>, considering the block time on Ethereum is generally about 14 seconds, it's possible to predict the time delta between blocks. However, block times are not constant and are subject to change for a variety of reasons, e.g. fork reorganisations and the difficulty bomb. Due to variable block times, <code>block.number</code> should also not be relied on for precise calculations of time.</p>"},{"location":"docs/SWC-116/#remediation","title":"Remediation","text":"<p>Developers should write smart contracts with the notion that block values are not precise, and the use of them can lead to unexpected effects. Alternatively, they may make use oracles.</p>"},{"location":"docs/SWC-116/#references","title":"References","text":"<ul> <li>Safety: Timestamp dependence</li> <li>Ethereum Smart Contract Best Practices - Timestamp Dependence</li> <li>How do Ethereum mining nodes maintain a time consistent with the network?</li> <li>Solidity: Timestamp dependency, is it possible to do safely?</li> <li>Avoid using block.number as a timestamp</li> </ul>"},{"location":"docs/SWC-116/#samples","title":"Samples","text":""},{"location":"docs/SWC-116/#time_locksol","title":"time_lock.sol","text":"<pre><code>/*\n * @author: Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract TimeLock {\nstruct User {\nuint amount; // amount locked (in eth)\nuint unlockBlock; // minimum block to unlock eth\n}\n\nmapping(address =&gt; User) private users;\n\n// Tokens should be locked for exact time specified\nfunction lockEth(uint _time, uint _amount) public payable {\nrequire(msg.value == _amount, 'must send exact amount');\nusers[msg.sender].unlockBlock = block.number + (_time / 14);\nusers[msg.sender].amount = _amount;\n}\n\n// Withdraw tokens if lock period is over\nfunction withdraw() public {\nrequire(users[msg.sender].amount &gt; 0, 'no amount locked');\nrequire(block.number &gt;= users[msg.sender].unlockBlock, 'lock period not over');\n\nuint amount = users[msg.sender].amount;\nusers[msg.sender].amount = 0;\n(bool success, ) = msg.sender.call.value(amount)(\"\");\nrequire(success, 'transfer failed');\n}\n}\n</code></pre>"},{"location":"docs/SWC-116/#timed_crowdsalesol","title":"timed_crowdsale.sol","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract TimedCrowdsale {\n\nevent Finished();\nevent notFinished();\n\n// Sale should finish exactly at January 1, 2019\nfunction isSaleFinished() private returns (bool) {\nreturn block.timestamp &gt;= 1546300800;\n}\n\nfunction run() public {\nif (isSaleFinished()) {\nemit Finished();\n} else {\nemit notFinished();\n}\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-117/","title":"Title","text":"<p>Signature Malleability</p>"},{"location":"docs/SWC-117/#relationships","title":"Relationships","text":"<p>CWE-347: Improper Verification of Cryptographic Signature</p>"},{"location":"docs/SWC-117/#description","title":"Description","text":"<p>The implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possession of the private key and still be valid. The EVM specification defines several so-called \u2018precompiled\u2019 contracts one of them being <code>ecrecover</code> which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values v, r and s to create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.</p>"},{"location":"docs/SWC-117/#remediation","title":"Remediation","text":"<p>A signature should never be included into a signed message hash to check if previously messages have been processed by the contract.</p>"},{"location":"docs/SWC-117/#references","title":"References","text":"<p>Bitcoin Transaction Malleability CTF - Challenge</p>"},{"location":"docs/SWC-117/#samples","title":"Samples","text":""},{"location":"docs/SWC-117/#transaction_malleablitysol","title":"transaction_malleablity.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\ncontract transaction_malleablity{\nmapping(address =&gt; uint256) balances;\nmapping(bytes32 =&gt; bool) signatureUsed;\n\nconstructor(address[] owners, uint[] init){\nrequire(owners.length == init.length);\nfor(uint i=0; i &lt; owners.length; i ++){\nbalances[owners[i]] = init[i];\n}\n}\n\nfunction transfer(\nbytes _signature,\naddress _to,\nuint256 _value,\nuint256 _gasPrice,\nuint256 _nonce)\npublic\nreturns (bool)\n{\nbytes32 txid = keccak256(abi.encodePacked(getTransferHash(_to, _value, _gasPrice, _nonce), _signature));\nrequire(!signatureUsed[txid]);\n\naddress from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _nonce);\n\nrequire(balances[from] &gt; _value);\nbalances[from] -= _value;\nbalances[_to] += _value;\n\nsignatureUsed[txid] = true;\n}\n\nfunction recoverTransferPreSigned(\nbytes _sig,\naddress _to,\nuint256 _value,\nuint256 _gasPrice,\nuint256 _nonce)\npublic\nview\n    returns (address recovered)\n{\nreturn ecrecoverFromSig(getSignHash(getTransferHash(_to, _value, _gasPrice, _nonce)), _sig);\n}\n\nfunction getTransferHash(\naddress _to,\nuint256 _value,\nuint256 _gasPrice,\nuint256 _nonce)\npublic\nview\n    returns (bytes32 txHash) {\nreturn keccak256(address(this), bytes4(0x1296830d), _to, _value, _gasPrice, _nonce);\n}\n\nfunction getSignHash(bytes32 _hash)\npublic\npure\n    returns (bytes32 signHash)\n{\nreturn keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash);\n}\n\nfunction ecrecoverFromSig(bytes32 hash, bytes sig)\npublic\npure\n    returns (address recoveredAddress)\n{\nbytes32 r;\nbytes32 s;\nuint8 v;\nif (sig.length != 65) return address(0);\nassembly {\nr := mload(add(sig, 32))\ns := mload(add(sig, 64))\nv := byte(0, mload(add(sig, 96)))\n}\nif (v &lt; 27) {\nv += 27;\n}\nif (v != 27 &amp;&amp; v != 28) return address(0);\nreturn ecrecover(hash, v, r, s);\n}\n}\n</code></pre>"},{"location":"docs/SWC-117/#transaction_malleablity_fixedsol","title":"transaction_malleablity_fixed.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\ncontract transaction_malleablity{\nmapping(address =&gt; uint256) balances;\nmapping(bytes32 =&gt; bool) signatureUsed;\n\nconstructor(address[] owners, uint[] init){\nrequire(owners.length == init.length);\nfor(uint i=0; i &lt; owners.length; i ++){\nbalances[owners[i]] = init[i];\n}\n}\n\nfunction transfer(\nbytes _signature,\naddress _to,\nuint256 _value,\nuint256 _gasPrice,\nuint256 _nonce)\npublic\nreturns (bool)\n{\nbytes32 txid = getTransferHash(_to, _value, _gasPrice, _nonce);\nrequire(!signatureUsed[txid]);\n\naddress from = recoverTransferPreSigned(_signature, _to, _value, _gasPrice, _nonce);\n\nrequire(balances[from] &gt; _value);\nbalances[from] -= _value;\nbalances[_to] += _value;\n\nsignatureUsed[txid] = true;\n}\n\nfunction recoverTransferPreSigned(\nbytes _sig,\naddress _to,\nuint256 _value,\nuint256 _gasPrice,\nuint256 _nonce)\npublic\nview\n    returns (address recovered)\n{\nreturn ecrecoverFromSig(getSignHash(getTransferHash(_to, _value, _gasPrice, _nonce)), _sig);\n}\n\nfunction getTransferHash(\naddress _to,\nuint256 _value,\nuint256 _gasPrice,\nuint256 _nonce)\npublic\nview\n    returns (bytes32 txHash) {\nreturn keccak256(address(this), bytes4(0x1296830d), _to, _value, _gasPrice, _nonce);\n}\n\nfunction getSignHash(bytes32 _hash)\npublic\npure\n    returns (bytes32 signHash)\n{\nreturn keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash);\n}\n\nfunction ecrecoverFromSig(bytes32 hash, bytes sig)\npublic\npure\n    returns (address recoveredAddress)\n{\nbytes32 r;\nbytes32 s;\nuint8 v;\nif (sig.length != 65) return address(0);\nassembly {\nr := mload(add(sig, 32))\ns := mload(add(sig, 64))\nv := byte(0, mload(add(sig, 96)))\n}\nif (v &lt; 27) {\nv += 27;\n}\nif (v != 27 &amp;&amp; v != 28) return address(0);\nreturn ecrecover(hash, v, r, s);\n}\n}\n</code></pre>"},{"location":"docs/SWC-118/","title":"Title","text":"<p>Incorrect Constructor Name</p>"},{"location":"docs/SWC-118/#relationships","title":"Relationships","text":"<p>CWE-665: Improper Initialization</p>"},{"location":"docs/SWC-118/#description","title":"Description","text":"<p>Constructors are special functions that are called only once during the contract creation. They often perform critical, privileged actions such as setting the owner of the contract. Before Solidity version 0.4.22, the only way of defining a constructor was to create a function with the same name as the contract class containing it. A function meant to become a constructor becomes a normal, callable function if its name doesn't exactly match the contract name. This behavior sometimes leads to security issues, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly.</p>"},{"location":"docs/SWC-118/#remediation","title":"Remediation","text":"<p>Solidity version 0.4.22 introduces a new <code>constructor</code> keyword that make a constructor definitions clearer. It is therefore recommended to upgrade the contract to a recent version of the Solidity compiler and change to the new constructor declaration.</p>"},{"location":"docs/SWC-118/#references","title":"References","text":"<ul> <li>SigmaPrime - Constructors with Care</li> </ul>"},{"location":"docs/SWC-118/#samples","title":"Samples","text":""},{"location":"docs/SWC-118/#incorrect_constructor_name1sol","title":"incorrect_constructor_name1.sol","text":"<pre><code>/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\n\npragma solidity 0.4.24;\n\ncontract Missing{\naddress private owner;\n\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\n\nfunction missing()\npublic {\nowner = msg.sender;\n}\n\nfunction () payable {} function withdraw() public onlyowner\n    {\nowner.transfer(this.balance);\n}\n}\n</code></pre>"},{"location":"docs/SWC-118/#incorrect_constructor_name1_fixedsol","title":"incorrect_constructor_name1_fixed.sol","text":"<pre><code>/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\n\npragma solidity ^0.4.24;\n\ncontract Missing{\naddress private owner;\n\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\n\nconstructor()\npublic\n{\nowner = msg.sender;\n}\n\nfunction () payable {}\n\nfunction withdraw()\npublic\nonlyowner\n    {\nowner.transfer(this.balance);\n}\n}\n</code></pre>"},{"location":"docs/SWC-118/#incorrect_constructor_name2sol","title":"incorrect_constructor_name2.sol","text":"<pre><code>/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\npragma solidity 0.4.24;\n\ncontract Missing{\naddress private owner;\n\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\n\nfunction Constructor()\npublic {\nowner = msg.sender;\n}\n\nfunction () payable {} function withdraw() public onlyowner\n    {\nowner.transfer(this.balance);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-118/#incorrect_constructor_name2_fixedsol","title":"incorrect_constructor_name2_fixed.sol","text":"<pre><code>/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * Modified by Gerhard Wagner\n */\n\npragma solidity ^0.4.24;\n\ncontract Missing{\naddress private owner;\n\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\n\nconstructor()\npublic\n{\nowner = msg.sender;\n}\n\nfunction () payable {}\n\nfunction withdraw()\npublic\nonlyowner\n    {\nowner.transfer(this.balance);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-119/","title":"Title","text":"<p>Shadowing State Variables</p>"},{"location":"docs/SWC-119/#relationships","title":"Relationships","text":"<p>CWE-710: Improper Adherence to Coding Standards</p>"},{"location":"docs/SWC-119/#description","title":"Description","text":"<p>Solidity allows for ambiguous naming of state variables when inheritance is used. Contract <code>A</code> with a variable <code>x</code> could inherit contract <code>B</code> that also has a state variable <code>x</code> defined. This would result in two separate versions of <code>x</code>, one of them being accessed from contract <code>A</code> and the other one from contract <code>B</code>. In more complex contract systems this condition could go unnoticed and subsequently lead to security issues.</p> <p>Shadowing state variables can also occur within a single contract when there are multiple definitions on the contract and function level.</p>"},{"location":"docs/SWC-119/#remediation","title":"Remediation","text":"<p>Review storage variable layouts for your contract systems carefully and remove any ambiguities. Always check for compiler warnings as they can flag the issue within a single contract.</p>"},{"location":"docs/SWC-119/#references","title":"References","text":"<ul> <li>Issue on Solidity's Github - Shadowing of inherited state variables should be an error (override keyword)</li> <li>Issue on Solidity's Github - Warn about shadowing state variables</li> </ul>"},{"location":"docs/SWC-119/#samples","title":"Samples","text":""},{"location":"docs/SWC-119/#shadowinginfunctionssol","title":"ShadowingInFunctions.sol","text":"<pre><code>pragma solidity 0.4.24;\n\ncontract ShadowingInFunctions {\nuint n = 2;\nuint x = 3;\n\nfunction test1() constant returns (uint n) {\nreturn n; // Will return 0\n}\n\nfunction test2() constant returns (uint n) {\nn = 1;\nreturn n; // Will return 1\n}\n\nfunction test3() constant returns (uint x) {\nuint n = 4;\nreturn n+x; // Will return 4\n}\n}\n</code></pre>"},{"location":"docs/SWC-119/#tokensalesol","title":"TokenSale.sol","text":"<pre><code>pragma solidity 0.4.24;\n\ncontract Tokensale {\nuint hardcap = 10000 ether;\n\nfunction Tokensale() {}\n\nfunction fetchCap() public constant returns(uint) {\nreturn hardcap;\n}\n}\n\ncontract Presale is Tokensale {\nuint hardcap = 1000 ether;\n\nfunction Presale() Tokensale() {}\n}\n</code></pre>"},{"location":"docs/SWC-119/#tokensale_fixedsol","title":"TokenSale_fixed.sol","text":"<pre><code>pragma solidity 0.4.25;\n\n//We fix the problem by eliminating the declaration which overrides the prefered hardcap.\n\ncontract Tokensale {\nuint public hardcap = 10000 ether;\n\nfunction Tokensale() {}\n\nfunction fetchCap() public constant returns(uint) {\nreturn hardcap;\n}\n}\n\ncontract Presale is Tokensale {\n//uint hardcap = 1000 ether;\n//If the hardcap variables were both needed we would have to rename one to fix this.\nfunction Presale() Tokensale() {\nhardcap = 1000 ether; //We set the hardcap from the constructor for the Tokensale to be 1000 instead of 10000\n}\n}\n</code></pre>"},{"location":"docs/SWC-120/","title":"Title","text":"<p>Weak Sources of Randomness from Chain Attributes</p>"},{"location":"docs/SWC-120/#relationships","title":"Relationships","text":"<p>CWE-330: Use of Insufficiently Random Values</p>"},{"location":"docs/SWC-120/#description","title":"Description","text":"<p>Ability to generate random numbers is very helpful in all kinds of applications. One obvious example is gambling DApps, where pseudo-random number generator is used to pick the winner. However, creating a strong enough source of randomness in Ethereum is very challenging. For example, use of <code>block.timestamp</code> is insecure, as a miner can choose to provide any timestamp within a few seconds and still get his block accepted by others. Use of <code>blockhash</code>, <code>block.difficulty</code> and other fields is also insecure, as they're controlled by the miner. If the stakes are high, the miner can mine lots of blocks in a short time by renting hardware, pick the block that has required block hash for him to win, and drop all others.</p>"},{"location":"docs/SWC-120/#remediation","title":"Remediation","text":"<ul> <li>Using external sources of randomness via oracles, and cryptographically checking the outcome of the oracle on-chain. e.g. Chainlink VRF. This approach does not rely on trusting the oracle, as a falsly generated random number will be rejected by the on-chain portion of the system.</li> <li>Using commitment scheme, e.g. RANDAO.</li> <li>Using external sources of randomness via oracles, e.g. Oraclize. Note that this approach requires trusting in oracle, thus it may be reasonable to use multiple oracles.</li> <li>Using Bitcoin block hashes, as they are more expensive to mine.</li> </ul>"},{"location":"docs/SWC-120/#references","title":"References","text":"<ul> <li>How can I securely generate a random number in my smart contract?</li> <li>When can BLOCKHASH be safely used for a random number? When would it be unsafe?</li> <li>The Run smart contract</li> </ul>"},{"location":"docs/SWC-120/#samples","title":"Samples","text":""},{"location":"docs/SWC-120/#guess_the_random_numbersol","title":"guess_the_random_number.sol","text":"<pre><code>/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\nuint8 answer;\n\nfunction GuessTheRandomNumberChallenge() public payable {\nrequire(msg.value == 1 ether);\nanswer = uint8(keccak256(block.blockhash(block.number - 1), now));\n}\n\nfunction isComplete() public view returns (bool) {\nreturn address(this).balance == 0;\n}\n\nfunction guess(uint8 n) public payable {\nrequire(msg.value == 1 ether);\n\nif (n == answer) {\nmsg.sender.transfer(2 ether);\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-120/#guess_the_random_number_fixedsol","title":"guess_the_random_number_fixed.sol","text":"<pre><code>/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n */\n\npragma solidity ^0.4.25;\n\ncontract GuessTheRandomNumberChallenge {\nuint8 answer;\nuint8 commitedGuess;\nuint commitBlock;\naddress guesser;\n\nfunction GuessTheRandomNumberChallenge() public payable {\nrequire(msg.value == 1 ether);\n}\n\nfunction isComplete() public view returns (bool) {\nreturn address(this).balance == 0;\n}\n\n//Guess the modulo of the blockhash 20 blocks from your guess\nfunction guess(uint8 _guess) public payable {\nrequire(msg.value == 1 ether);\ncommitedGuess = _guess;\ncommitBlock = block.number;\nguesser = msg.sender;\n}\nfunction recover() public {\n//This must be called after the guessed block and before commitBlock+20's blockhash is unrecoverable\nrequire(block.number &gt; commitBlock + 20 &amp;&amp; commitBlock+20 &gt; block.number - 256);\nrequire(guesser == msg.sender);\n\nif(uint(blockhash(commitBlock+20)) == commitedGuess){\nmsg.sender.transfer(2 ether);\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-120/#old_blockhashsol","title":"old_blockhash.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\n//Based on the the Capture the Ether challange at https://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\nstruct guess{\nuint block;\nbytes32 guess;\n}\n\nmapping(address =&gt; guess) guesses;\n\nconstructor() public payable {\nrequire(msg.value == 1 ether);\n}\n\nfunction lockInGuess(bytes32 hash) public payable {\nrequire(guesses[msg.sender].block == 0);\nrequire(msg.value == 1 ether);\n\nguesses[msg.sender].guess = hash;\nguesses[msg.sender].block  = block.number + 1;\n}\n\nfunction settle() public {\nrequire(block.number &gt; guesses[msg.sender].block);\n\nbytes32 answer = blockhash(guesses[msg.sender].block);\n\nguesses[msg.sender].block = 0;\nif (guesses[msg.sender].guess == answer) {\nmsg.sender.transfer(2 ether);\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-120/#old_blockhash_fixedsol","title":"old_blockhash_fixed.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\n//Based on the the Capture the Ether challange at https://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\nstruct guess{\nuint block;\nbytes32 guess;\n}\n\nmapping(address =&gt; guess) guesses;\n\nconstructor() public payable {\nrequire(msg.value == 1 ether);\n}\n\nfunction lockInGuess(bytes32 hash) public payable {\nrequire(guesses[msg.sender].block == 0);\nrequire(msg.value == 1 ether);\n\nguesses[msg.sender].guess = hash;\nguesses[msg.sender].block  = block.number + 1;\n}\n\nfunction settle() public {\nrequire(block.number &gt; guesses[msg.sender].block +10);\n//Note that this solution prevents the attack where blockhash(guesses[msg.sender].block) is zero\n//Also we add ten block cooldown period so that a minner cannot use foreknowlege of next blockhashes\nif(guesses[msg.sender].block - block.number &lt; 256){\nbytes32 answer = blockhash(guesses[msg.sender].block);\n\nguesses[msg.sender].block = 0;\nif (guesses[msg.sender].guess == answer) {\nmsg.sender.transfer(2 ether);\n}\n}\nelse{\nrevert(\"Sorry your lottery ticket has expired\");\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-120/#random_number_generatorsol","title":"random_number_generator.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\nuint256 private salt =  block.timestamp;\n\nfunction random(uint max) view private returns (uint256 result) {\n// Get the best seed for randomness\nuint256 x = salt * 100 / max;\nuint256 y = salt * block.number / (salt % 5);\nuint256 seed = block.number / 3 + (salt % 300) + y;\nuint256 h = uint256(blockhash(seed));\n// Random number between 1 and max\nreturn uint256((h / x)) % max + 1;\n}\n}\n</code></pre>"},{"location":"docs/SWC-121/","title":"Title","text":"<p>Missing Protection against Signature Replay Attacks</p>"},{"location":"docs/SWC-121/#relationships","title":"Relationships","text":"<p>CWE-347: Improper Verification of Cryptographic Signature</p>"},{"location":"docs/SWC-121/#description","title":"Description","text":"<p>It is sometimes necessary to perform signature verification in smart contracts to achieve better usability or to save gas cost. A secure implementation needs to protect against Signature Replay Attacks by for example keeping track of all processed message hashes and only allowing new message hashes to be processed. A malicious user could attack a contract without such a control and get message hash that was sent by another user processed multiple times.</p>"},{"location":"docs/SWC-121/#remediation","title":"Remediation","text":"<p>In order to protect against signature replay attacks consider the following recommendations:</p> <ul> <li>Store every message hash that has been processed by the smart contract. When new messages are received check against the already existing ones and only proceed with the business logic if it's a new message hash.</li> <li>Include the address of the contract that processes the message. This ensures that the message can only be used in a single contract.</li> <li>Under no circumstances generate the message hash including the signature. The <code>ecrecover</code> function is susceptible to signature malleability (see also SWC-117).</li> </ul>"},{"location":"docs/SWC-121/#references","title":"References","text":"<ul> <li>Medium - Replay Attack Vulnerability in Ethereum Smart Contracts Introduced by transferProxy()</li> </ul>"},{"location":"docs/SWC-122/","title":"Title","text":"<p>Lack of Proper Signature Verification</p>"},{"location":"docs/SWC-122/#relationships","title":"Relationships","text":"<p>CWE-345: Insufficient Verification of Data Authenticity</p>"},{"location":"docs/SWC-122/#description","title":"Description","text":"<p>It is a common pattern for smart contract systems to allow users to sign messages off-chain instead of directly requesting users to do an on-chain transaction because of the flexibility and increased transferability that this provides. Smart contract systems that process signed messages have to implement their own logic to recover the authenticity from the signed messages before they process them further. A limitation for such systems is that smart contracts can not directly interact with them because they can not sign messages. Some signature verification implementations attempt to solve this problem by assuming the validity of a signed message based on other methods that do not have this limitation. An example of such a method is to rely on <code>msg.sender</code> and assume that if a signed message originated from the sender address then it has also been created by the sender address. This can lead to vulnerabilities especially in scenarios where proxies can be used to relay transactions.</p>"},{"location":"docs/SWC-122/#remediation","title":"Remediation","text":"<p>It is not recommended to use alternate verification schemes that do not require proper signature verification through <code>ecrecover()</code>.</p>"},{"location":"docs/SWC-122/#references","title":"References","text":"<ul> <li>Consensys Diligence 0x Audit Report - Insecure signature validator</li> </ul>"},{"location":"docs/SWC-123/","title":"Title","text":"<p>Requirement Violation</p>"},{"location":"docs/SWC-123/#relationships","title":"Relationships","text":"<p>CWE-573: Improper Following of Specification by Caller</p>"},{"location":"docs/SWC-123/#description","title":"Description","text":"<p>The Solidity <code>require()</code> construct is meant to validate external inputs of a function. In most cases, such external inputs are provided by callers, but they may also be returned by callees. In the former case, we refer to them as precondition violations. Violations of a requirement can indicate one of two possible issues:</p> <ol> <li>A bug exists in the contract that provided the external input.</li> <li>The condition used to express the requirement is too strong.</li> </ol>"},{"location":"docs/SWC-123/#remediation","title":"Remediation","text":"<p>If the required logical condition is too strong, it should be weakened to allow all valid external inputs.</p> <p>Otherwise, the bug must be in the contract that provided the external input and one should consider fixing its code by making sure no invalid inputs are provided.</p>"},{"location":"docs/SWC-123/#references","title":"References","text":"<ul> <li>The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the EVM</li> </ul>"},{"location":"docs/SWC-123/#samples","title":"Samples","text":""},{"location":"docs/SWC-123/#requirement_simplesol","title":"requirement_simple.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\ncontract Bar {\nFoo private f = new Foo();\nfunction doubleBaz() public view returns (int256) {\nreturn 2 * f.baz(0);\n}\n}\n\ncontract Foo {\nfunction baz(int256 x) public pure returns (int256) {\nrequire(0 &lt; x);\nreturn 42;\n}\n}\n</code></pre>"},{"location":"docs/SWC-123/#requirement_simple_fixedsol","title":"requirement_simple_fixed.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\ncontract Bar {\nFoo private f = new Foo();\nfunction doubleBaz() public view returns (int256) {\nreturn 2 * f.baz(1); //Changes the external contract to not hit the overly strong requirement.\n}\n}\n\ncontract Foo {\nfunction baz(int256 x) public pure returns (int256) {\nrequire(0 &lt; x); //You can also fix the contract by changing the input to the uint type and removing the require\nreturn 42;\n}\n}\n</code></pre>"},{"location":"docs/SWC-124/","title":"Title","text":"<p>Write to Arbitrary Storage Location</p>"},{"location":"docs/SWC-124/#relationships","title":"Relationships","text":"<p>CWE-123: Write-what-where Condition</p>"},{"location":"docs/SWC-124/#description","title":"Description","text":"<p>A smart contract's data (e.g., storing the owner of the contract) is persistently stored at some storage location (i.e., a key or address) on the EVM level. The contract is responsible for ensuring that only authorized user or contract accounts may write to sensitive storage locations. If an attacker is able to write to arbitrary storage locations of a contract, the authorization checks may easily be circumvented. This can allow an attacker to corrupt the storage; for instance, by overwriting a field that stores the address of the contract owner.</p>"},{"location":"docs/SWC-124/#remediation","title":"Remediation","text":"<p>As a general advice, given that all data structures share the same storage (address) space, one should make sure that writes to one data structure cannot inadvertently overwrite entries of another data structure.</p>"},{"location":"docs/SWC-124/#references","title":"References","text":"<ul> <li>Entry to Underhanded Solidity Coding Contest 2017 (honorable mention)</li> </ul>"},{"location":"docs/SWC-124/#samples","title":"Samples","text":""},{"location":"docs/SWC-124/#arbitrary_location_write_simplesol","title":"arbitrary_location_write_simple.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\ncontract Wallet {\nuint[] private bonusCodes;\naddress private owner;\n\nconstructor() public {\nbonusCodes = new uint[](0);\nowner = msg.sender;\n}\n\nfunction () public payable {\n}\n\nfunction PushBonusCode(uint c) public {\nbonusCodes.push(c);\n}\n\nfunction PopBonusCode() public {\nrequire(0 &lt;= bonusCodes.length);\nbonusCodes.length--;\n}\n\nfunction UpdateBonusCodeAt(uint idx, uint c) public {\nrequire(idx &lt; bonusCodes.length);\nbonusCodes[idx] = c;\n}\n\nfunction Destroy() public {\nrequire(msg.sender == owner);\nselfdestruct(msg.sender);\n}\n}\n</code></pre>"},{"location":"docs/SWC-124/#arbitrary_location_write_simple_fixedsol","title":"arbitrary_location_write_simple_fixed.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\ncontract Wallet {\nuint[] private bonusCodes;\naddress private owner;\n\nconstructor() public {\nbonusCodes = new uint[](0);\nowner = msg.sender;\n}\n\nfunction () public payable {\n}\n\nfunction PushBonusCode(uint c) public {\nbonusCodes.push(c);\n}\n\nfunction PopBonusCode() public {\nrequire(0 &lt; bonusCodes.length);\nbonusCodes.length--;\n}\n\nfunction UpdateBonusCodeAt(uint idx, uint c) public {\nrequire(idx &lt; bonusCodes.length); //Since you now have to push very codes this is no longer an arbitray write.\nbonusCodes[idx] = c;\n}\n\nfunction Destroy() public {\nrequire(msg.sender == owner);\nselfdestruct(msg.sender);\n}\n}\n</code></pre>"},{"location":"docs/SWC-124/#mapping_writesol","title":"mapping_write.sol","text":"<pre><code>pragma solidity ^0.4.24;\n\n//This code is derived from the Capture the Ether https://capturetheether.com/challenges/math/mapping/\n\ncontract Map {\naddress public owner;\nuint256[] map;\n\nfunction set(uint256 key, uint256 value) public {\nif (map.length &lt;= key) {\nmap.length = key + 1;\n}\n\nmap[key] = value;\n}\n\nfunction get(uint256 key) public view returns (uint256) {\nreturn map[key];\n}\nfunction withdraw() public{\nrequire(msg.sender == owner);\nmsg.sender.transfer(address(this).balance);\n}\n}\n</code></pre>"},{"location":"docs/SWC-125/","title":"Title","text":"<p>Incorrect Inheritance Order</p>"},{"location":"docs/SWC-125/#relationships","title":"Relationships","text":"<p>CWE-696: Incorrect Behavior Order</p>"},{"location":"docs/SWC-125/#description","title":"Description","text":"<p>Solidity supports multiple inheritance, meaning that one contract can inherit several contracts. Multiple inheritance introduces ambiguity called Diamond Problem: if two or more base contracts define the same function, which one should be called in the child contract? Solidity deals with this ambiguity by using reverse C3 Linearization, which sets a priority between base contracts.</p> <p>That way, base contracts have different priorities, so the order of inheritance matters. Neglecting inheritance order can lead to unexpected behavior.</p>"},{"location":"docs/SWC-125/#remediation","title":"Remediation","text":"<p>When inheriting multiple contracts, especially if they have identical functions, a developer should carefully specify inheritance in the correct order. The rule of thumb is to inherit contracts from more /general/ to more /specific/.</p>"},{"location":"docs/SWC-125/#references","title":"References","text":"<ul> <li>Smart Contract Best Practices - Complex Inheritance</li> <li>Solidity docs - Multiple Inheritance and Linearization</li> <li>Solidity anti-patterns: Fun with inheritance DAG abuse</li> </ul>"},{"location":"docs/SWC-125/#samples","title":"Samples","text":""},{"location":"docs/SWC-125/#mdtcrowdsalesol","title":"MDTCrowdsale.sol","text":"<pre><code>/*\n * @source: https://github.com/Arachnid/uscc/blob/master/submissions-2017/philipdaian/MDTCrowdsale.sol\n * @author: Philip Daian\n */\n\npragma solidity ^0.4.25;\n\n//import \"https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n/**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n// benefit is lost if 'b' is also tested.\n// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\nif (a == 0) {\nreturn 0;\n}\n\nuint256 c = a * b;\nrequire(c / a == b);\n\nreturn c;\n}\n\n/**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n// Solidity only automatically asserts when dividing by 0\nrequire(b &gt; 0);\nuint256 c = a / b;\n// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\nreturn c;\n}\n\n/**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b &lt;= a);\nuint256 c = a - b;\n\nreturn c;\n}\n\n/**\n    * @dev Adds two numbers, reverts on overflow.\n    */\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c = a + b;\nrequire(c &gt;= a);\n\nreturn c;\n}\n\n/**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b != 0);\nreturn a % b;\n}\n}\n\n//import \"https://github.com/OpenZeppelin/openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\";\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\nfunction totalSupply() external view returns (uint256);\n\nfunction balanceOf(address who) external view returns (uint256);\n\nfunction allowance(address owner, address spender) external view returns (uint256);\n\nfunction transfer(address to, uint256 value) external returns (bool);\n\nfunction approve(address spender, uint256 value) external returns (bool);\n\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\n\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\nusing SafeMath for uint256;\n\nmapping (address =&gt; uint256) private _balances;\n\nmapping (address =&gt; mapping (address =&gt; uint256)) private _allowed;\n\nuint256 private _totalSupply;\n\n/**\n    * @dev Total number of tokens in existence\n    */\nfunction totalSupply() public view returns (uint256) {\nreturn _totalSupply;\n}\n\n/**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\nfunction balanceOf(address owner) public view returns (uint256) {\nreturn _balances[owner];\n}\n\n/**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\nfunction allowance(address owner, address spender) public view returns (uint256) {\nreturn _allowed[owner][spender];\n}\n\n/**\n    * @dev Transfer token for a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\nfunction transfer(address to, uint256 value) public returns (bool) {\n_transfer(msg.sender, to, value);\nreturn true;\n}\n\n/**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\nfunction approve(address spender, uint256 value) public returns (bool) {\nrequire(spender != address(0));\n\n_allowed[msg.sender][spender] = value;\nemit Approval(msg.sender, spender, value);\nreturn true;\n}\n\n/**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\nfunction transferFrom(address from, address to, uint256 value) public returns (bool) {\n_allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n_transfer(from, to, value);\nemit Approval(from, msg.sender, _allowed[from][msg.sender]);\nreturn true;\n}\n\n/**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\nfunction increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\nrequire(spender != address(0));\n\n_allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\nemit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\nreturn true;\n}\n\n/**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\nfunction decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\nrequire(spender != address(0));\n\n_allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\nemit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\nreturn true;\n}\n\n/**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\nfunction _transfer(address from, address to, uint256 value) internal {\nrequire(to != address(0));\n\n_balances[from] = _balances[from].sub(value);\n_balances[to] = _balances[to].add(value);\nemit Transfer(from, to, value);\n}\n\n/**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\nfunction _mint(address account, uint256 value) internal {\nrequire(account != address(0));\n\n_totalSupply = _totalSupply.add(value);\n_balances[account] = _balances[account].add(value);\nemit Transfer(address(0), account, value);\n}\n\n/**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\nfunction _burn(address account, uint256 value) internal {\nrequire(account != address(0));\n\n_totalSupply = _totalSupply.sub(value);\n_balances[account] = _balances[account].sub(value);\nemit Transfer(account, address(0), value);\n}\n\n/**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\nfunction _burnFrom(address account, uint256 value) internal {\n_allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n_burn(account, value);\nemit Approval(account, msg.sender, _allowed[account][msg.sender]);\n}\n}\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\nstruct Role {\nmapping (address =&gt; bool) bearer;\n}\n\n/**\n     * @dev give an account access to this role\n     */\nfunction add(Role storage role, address account) internal {\nrequire(account != address(0));\nrequire(!has(role, account));\n\nrole.bearer[account] = true;\n}\n\n/**\n     * @dev remove an account's access to this role\n     */\nfunction remove(Role storage role, address account) internal {\nrequire(account != address(0));\nrequire(has(role, account));\n\nrole.bearer[account] = false;\n}\n\n/**\n     * @dev check if an account has this role\n     * @return bool\n     */\nfunction has(Role storage role, address account) internal view returns (bool) {\nrequire(account != address(0));\nreturn role.bearer[account];\n}\n}\n\ncontract MinterRole {\nusing Roles for Roles.Role;\n\nevent MinterAdded(address indexed account);\nevent MinterRemoved(address indexed account);\n\nRoles.Role private _minters;\n\nconstructor () internal {\n_addMinter(msg.sender);\n}\n\nmodifier onlyMinter() {\nrequire(isMinter(msg.sender));\n_;\n}\n\nfunction isMinter(address account) public view returns (bool) {\nreturn _minters.has(account);\n}\n\nfunction addMinter(address account) public onlyMinter {\n_addMinter(account);\n}\n\nfunction renounceMinter() public {\n_removeMinter(msg.sender);\n}\n\nfunction _addMinter(address account) internal {\n_minters.add(account);\nemit MinterAdded(account);\n}\n\nfunction _removeMinter(address account) internal {\n_minters.remove(account);\nemit MinterRemoved(account);\n}\n}\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n/**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\nfunction mint(address to, uint256 value) public onlyMinter returns (bool) {\n_mint(to, value);\nreturn true;\n}\n}\n/**\n * @title Crowdsale\n * @dev Crowdsale is a base contract for managing a token crowdsale.\n * Crowdsales have a start and end block, where investors can make\n * token purchases and the crowdsale will assign them tokens based\n * on a token per ETH rate. Funds collected are forwarded to a wallet\n * as they arrive.\n */\ncontract Crowdsale {\nusing SafeMath for uint256;\n\n// The token being sold\nERC20Mintable public token;\n\n// start and end block where investments are allowed (both inclusive)\nuint256 public startBlock;\nuint256 public endBlock;\n\n// address where funds are collected\naddress public wallet;\n\n// how many token units a buyer gets per wei\nuint256 public rate;\n\n// amount of raised money in wei\nuint256 public weiRaised;\n\n/**\n    * event for token purchase logging\n    * @param purchaser who paid for the tokens\n    * @param beneficiary who got the tokens\n    * @param value weis paid for purchase\n    * @param amount amount of tokens purchased\n    */\nevent TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n\nfunction Crowdsale(uint256 _startBlock, uint256 _endBlock, uint256 _rate, address _wallet) {\nrequire(_startBlock &gt;= block.number);\nrequire(_endBlock &gt;= _startBlock);\nrequire(_rate &gt; 0);\nrequire(_wallet != 0x0);\n\ntoken = createTokenContract();\nstartBlock = _startBlock;\nendBlock = _endBlock;\nrate = _rate;\nwallet = _wallet;\n}\n\n// creates the token to be sold.\n// override this method to have crowdsale of a specific mintable token.\nfunction createTokenContract() internal returns (ERC20Mintable) {\nreturn new ERC20Mintable();\n}\n\n\n// fallback function can be used to buy tokens\nfunction () payable {\nbuyTokens(msg.sender);\n}\n\n// low level token purchase function\nfunction buyTokens(address beneficiary) payable {\nrequire(beneficiary != 0x0);\nrequire(validPurchase());\n\nuint256 weiAmount = msg.value;\n\n// calculate token amount to be created\nuint256 tokens = weiAmount.mul(rate);\n\n// update state\nweiRaised = weiRaised.add(weiAmount);\n\ntoken.mint(beneficiary, tokens);\nTokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n\nforwardFunds();\n}\n\n// send ether to the fund collection wallet\n// override to create custom fund forwarding mechanisms\nfunction forwardFunds() internal {\nwallet.transfer(msg.value);\n}\n\n// @return true if the transaction can buy tokens\nfunction validPurchase() internal constant returns (bool) {\nuint256 current = block.number;\nbool withinPeriod = current &gt;= startBlock &amp;&amp; current &lt;= endBlock;\nbool nonZeroPurchase = msg.value != 0;\nreturn withinPeriod &amp;&amp; nonZeroPurchase;\n}\n\n// @return true if crowdsale event has ended\nfunction hasEnded() public constant returns (bool) {\nreturn block.number &gt; endBlock;\n}\n}\n\n/**\n * @title CappedCrowdsale\n * @dev Extension of Crowsdale with a max amount of funds raised\n */\ncontract CappedCrowdsale is Crowdsale {\nusing SafeMath for uint256;\nuint256 public cap;\n\nfunction CappedCrowdsale(uint256 _cap) {\nrequire(_cap &gt; 0);\ncap = _cap;\n}\n\n// overriding Crowdsale#validPurchase to add extra cap logic\n// @return true if investors can buy at the moment\nfunction validPurchase() internal constant returns (bool) {\nbool withinCap = weiRaised.add(msg.value) &lt;= cap;\nreturn super.validPurchase() &amp;&amp; withinCap;\n}\n\n// overriding Crowdsale#hasEnded to add cap logic\n// @return true if crowdsale event has ended\nfunction hasEnded() public constant returns (bool) {\nbool capReached = weiRaised &gt;= cap;\nreturn super.hasEnded() || capReached;\n}\n}\n\n/**\n * @title WhitelistedCrowdsale\n * @dev Extension of Crowsdale with a whitelist of investors that\n * can buy before the start block\n */\ncontract WhitelistedCrowdsale is Crowdsale {\nusing SafeMath for uint256;\n\nmapping (address =&gt; bool) public whitelist;\n\nfunction addToWhitelist(address addr) {\nrequire(msg.sender != address(this));\nwhitelist[addr] = true;\n}\n\n// overriding Crowdsale#validPurchase to add extra whitelit logic\n// @return true if investors can buy at the moment\nfunction validPurchase() internal constant returns (bool) {\nreturn super.validPurchase() || (whitelist[msg.sender] &amp;&amp; !hasEnded());\n}\n\n}\n\ncontract MDTCrowdsale is CappedCrowdsale, WhitelistedCrowdsale {\n\nfunction MDTCrowdsale()\nCappedCrowdsale(50000000000000000000000)\nCrowdsale(block.number, block.number + 100000, 1, msg.sender) { // Wallet is the contract creator, to whom funds will be sent\naddToWhitelist(msg.sender);\naddToWhitelist(0x0d5bda9db5dd36278c6a40683960ba58cac0149b);\naddToWhitelist(0x1b6ddc637c24305b354d7c337f9126f68aad4886);\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-126/","title":"Title","text":"<p>Insufficient Gas Griefing</p>"},{"location":"docs/SWC-126/#relationships","title":"Relationships","text":"<p>CWE-691: Insufficient Control Flow Management</p>"},{"location":"docs/SWC-126/#description","title":"Description","text":"<p>Insufficient gas griefing attacks can be performed on contracts which accept data and use it in a sub-call on another contract. If the sub-call fails, either the whole transaction is reverted, or execution is continued. In the case of a relayer contract, the user who executes the transaction, the 'forwarder', can effectively censor transactions by using just enough gas to execute the transaction, but not enough for the sub-call to succeed.</p>"},{"location":"docs/SWC-126/#remediation","title":"Remediation","text":"<p>There are two options to prevent insufficient gas griefing:</p> <ul> <li>Only allow trusted users to relay transactions.</li> <li>Require that the forwarder provides enough gas.</li> </ul>"},{"location":"docs/SWC-126/#references","title":"References","text":"<ul> <li>Consensys Smart Contract Best Practices</li> <li>What does griefing mean?</li> <li>Griefing Attacks: Are they profitable for the attacker?</li> </ul>"},{"location":"docs/SWC-126/#samples","title":"Samples","text":""},{"location":"docs/SWC-126/#relayersol","title":"relayer.sol","text":"<pre><code>/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing\n * @author: ConsenSys Diligence\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract Relayer {\nuint transactionId;\n\nstruct Tx {\nbytes data;\nbool executed;\n}\n\nmapping (uint =&gt; Tx) transactions;\n\nfunction relay(Target target, bytes memory _data) public returns(bool) {\n// replay protection; do not call the same transaction twice\nrequire(transactions[transactionId].executed == false, 'same transaction twice');\ntransactions[transactionId].data = _data;\ntransactions[transactionId].executed = true;\ntransactionId += 1;\n\n(bool success, ) = address(target).call(abi.encodeWithSignature(\"execute(bytes)\", _data));\nreturn success;\n}\n}\n\n// Contract called by Relayer\ncontract Target {\nfunction execute(bytes memory _data) public {\n// Execute contract code\n}\n}\n</code></pre>"},{"location":"docs/SWC-126/#relayer_fixedsol","title":"relayer_fixed.sol","text":"<pre><code>/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#insufficient-gas-griefing\n * @author: ConsenSys Diligence\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract Relayer {\nuint transactionId;\n\nstruct Tx {\nbytes data;\nbool executed;\n}\n\nmapping (uint =&gt; Tx) transactions;\n\nfunction relay(Target target, bytes memory _data, uint _gasLimit) public {\n// replay protection; do not call the same transaction twice\nrequire(transactions[transactionId].executed == false, 'same transaction twice');\ntransactions[transactionId].data = _data;\ntransactions[transactionId].executed = true;\ntransactionId += 1;\n\naddress(target).call(abi.encodeWithSignature(\"execute(bytes)\", _data, _gasLimit));\n}\n}\n\n// Contract called by Relayer\ncontract Target {\nfunction execute(bytes memory _data, uint _gasLimit) public {\nrequire(gasleft() &gt;= _gasLimit, 'not enough gas');\n// Execute contract code\n}\n}\n</code></pre>"},{"location":"docs/SWC-127/","title":"Title","text":"<p>Arbitrary Jump with Function Type Variable</p>"},{"location":"docs/SWC-127/#relationships","title":"Relationships","text":"<p>CWE-695: Use of Low-Level Functionality</p>"},{"location":"docs/SWC-127/#description","title":"Description","text":"<p>Solidity supports function types. That is, a variable of function type can be assigned with a reference to a function with a matching signature. The function saved to such variable can be called just like a regular function.</p> <p>The problem arises when a user has the ability to arbitrarily change the function type variable and thus execute random code instructions. As Solidity doesn't support pointer arithmetics, it's impossible to change such variable to an arbitrary value. However, if the developer uses assembly instructions, such as <code>mstore</code> or assign operator, in the worst case scenario an attacker is able to point a function type variable to any code instruction, violating required validations and required state changes.</p>"},{"location":"docs/SWC-127/#remediation","title":"Remediation","text":"<p>The use of assembly should be minimal. A developer should not allow a user to assign arbitrary values to function type variables.</p>"},{"location":"docs/SWC-127/#references","title":"References","text":"<ul> <li>Solidity CTF</li> <li>Solidity docs - Solidity Assembly</li> <li>Solidity docs - Function Types</li> </ul>"},{"location":"docs/SWC-127/#samples","title":"Samples","text":""},{"location":"docs/SWC-127/#functiontypessol","title":"FunctionTypes.sol","text":"<pre><code>/*\n * @source: https://gist.github.com/wadeAlexC/7a18de852693b3f890560ab6a211a2b8\n * @author: Alexander Wade\n */\n\npragma solidity ^0.4.25;\n\ncontract FunctionTypes {\n\nconstructor() public payable { require(msg.value != 0); }\n\nfunction withdraw() private {\nrequire(msg.value == 0, 'dont send funds!');\naddress(msg.sender).transfer(address(this).balance);\n}\n\nfunction frwd() internal\n{ withdraw(); }\n\nstruct Func { function () internal f; }\n\nfunction breakIt() public payable {\nrequire(msg.value != 0, 'send funds!');\nFunc memory func;\nfunc.f = frwd;\nassembly { mstore(func, add(mload(func), callvalue)) }\nfunc.f();\n}\n}\n</code></pre>"},{"location":"docs/SWC-128/","title":"Title","text":"<p>DoS With Block Gas Limit</p>"},{"location":"docs/SWC-128/#relationships","title":"Relationships","text":"<p>CWE-400: Uncontrolled Resource Consumption</p>"},{"location":"docs/SWC-128/#description","title":"Description","text":"<p>When smart contracts are deployed or functions inside them are called, the execution of these actions always requires a certain amount of gas, based of how much computation is needed to complete them. The Ethereum network specifies a block gas limit and the sum of all transactions included in a block can not exceed the threshold.</p> <p>Programming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. Modifying an array of unknown size, that increases in size over time, can lead to such a Denial of Service condition.</p>"},{"location":"docs/SWC-128/#remediation","title":"Remediation","text":"<p>Caution is advised when you expect to have large arrays that grow over time. Actions that require looping across the entire data structure should be avoided.</p> <p>If you absolutely must loop over an array of unknown size, then you should plan for it to potentially take multiple blocks, and therefore require multiple transactions.</p>"},{"location":"docs/SWC-128/#references","title":"References","text":"<ul> <li>Ethereum Design Rationale</li> <li>Ethereum Yellow Paper</li> <li>Clear Large Array Without Blowing Gas Limit</li> <li>GovernMental jackpot payout DoS Gas</li> </ul>"},{"location":"docs/SWC-128/#samples","title":"Samples","text":""},{"location":"docs/SWC-128/#dos_addresssol","title":"dos_address.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\ncontract DosGas {\n\naddress[] creditorAddresses;\nbool win = false;\n\nfunction emptyCreditors() public {\nif(creditorAddresses.length&gt;1500) {\ncreditorAddresses = new address[](0);\nwin = true;\n}\n}\n\nfunction addCreditors() public returns (bool) {\nfor(uint i=0;i&lt;350;i++) {\ncreditorAddresses.push(msg.sender);\n}\nreturn true;\n}\n\nfunction iWin() public view returns (bool) {\nreturn win;\n}\n\nfunction numberCreditors() public view returns (uint) {\nreturn creditorAddresses.length;\n}\n}\n</code></pre>"},{"location":"docs/SWC-128/#dos_numbersol","title":"dos_number.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\ncontract DosNumber {\n\nuint numElements = 0;\nuint[] array;\n\nfunction insertNnumbers(uint value,uint numbers) public {\n\n// Gas DOS if number &gt; 382 more or less, it depends on actual gas limit\nfor(uint i=0;i&lt;numbers;i++) {\nif(numElements == array.length) {\narray.length += 1;\n}\narray[numElements++] = value;\n}\n}\n\nfunction clear() public {\nrequire(numElements&gt;1500);\nnumElements = 0;\n}\n\n// Gas DOS clear\nfunction clearDOS() public {\n\n// number depends on actual gas limit\nrequire(numElements&gt;1500);\narray = new uint[](0);\nnumElements = 0;\n}\n\nfunction getLengthArray() public view returns(uint) {\nreturn numElements;\n}\n\nfunction getRealLengthArray() public view returns(uint) {\nreturn array.length;\n}\n}\n</code></pre>"},{"location":"docs/SWC-128/#dos_simplesol","title":"dos_simple.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\ncontract DosOneFunc {\n\naddress[] listAddresses;\n\nfunction ifillArray() public returns (bool){\nif(listAddresses.length&lt;1500) {\n\nfor(uint i=0;i&lt;350;i++) {\nlistAddresses.push(msg.sender);\n}\nreturn true;\n\n} else {\nlistAddresses = new address[](0);\nreturn false;\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-129/","title":"Title","text":"<p>Typographical Error</p>"},{"location":"docs/SWC-129/#relationships","title":"Relationships","text":"<p>CWE-480: Use of Incorrect Operator</p>"},{"location":"docs/SWC-129/#description","title":"Description","text":"<p>A typographical error can occur for example when the intent of a defined operation is to sum a number to a variable (+=) but it has accidentally been defined in a wrong way (=+), introducing a typo which happens to be a valid operator. Instead of calculating the sum it initializes the variable again.</p> <p>The unary + operator is deprecated in new solidity compiler versions.</p>"},{"location":"docs/SWC-129/#remediation","title":"Remediation","text":"<p>The weakness can be avoided by performing pre-condition checks on any math operation or using a vetted library for arithmetic calculations such as SafeMath developed by OpenZeppelin.</p>"},{"location":"docs/SWC-129/#references","title":"References","text":"<ul> <li>HackerGold Bug Analysis</li> <li>SafeMath by OpenZeppelin</li> <li>Disallow Unary plus</li> </ul>"},{"location":"docs/SWC-129/#samples","title":"Samples","text":""},{"location":"docs/SWC-129/#typo_one_commandsol","title":"typo_one_command.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\ncontract TypoOneCommand {\nuint numberOne = 1;\n\nfunction alwaysOne() public {\nnumberOne =+ 1;\n}\n}\n</code></pre>"},{"location":"docs/SWC-129/#typo_safe_mathsol","title":"typo_safe_math.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\n/** Taken from the OpenZeppelin github\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n/**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n// benefit is lost if 'b' is also tested.\n// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\nif (a == 0) {\nreturn 0;\n}\n\nuint256 c = a * b;\nrequire(c / a == b);\n\nreturn c;\n}\n\n/**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b &gt; 0); // Solidity only automatically asserts when dividing by 0\nuint256 c = a / b;\n// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\nreturn c;\n}\n\n/**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b &lt;= a);\nuint256 c = a - b;\n\nreturn c;\n}\n\n/**\n  * @dev Adds two numbers, reverts on overflow.\n  */\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c = a + b;\nrequire(c &gt;= a);\n\nreturn c;\n}\n\n/**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b != 0);\nreturn a % b;\n}\n}\n\n\ncontract TypoSafeMath {\n\nusing SafeMath for uint256;\nuint256 public numberOne = 1;\nbool public win = false;\n\nfunction addOne() public {\nnumberOne =+ 1;\n}\n\nfunction addOneCorrect() public {\nnumberOne += 1;\n}\n\nfunction addOneSafeMath() public  {\nnumberOne = numberOne.add(1);\n}\n\nfunction iWin() public {\nif(!win &amp;&amp; numberOne&gt;3) {\nwin = true;\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-129/#typo_simplesol","title":"typo_simple.sol","text":"<pre><code>pragma solidity ^0.4.25;\n\ncontract TypoSimple {\n\nuint onlyOne = 1;\nbool win = false;\n\nfunction addOne() public {\nonlyOne =+ 1;\nif(onlyOne&gt;1) {\nwin = true;\n}\n}\n\nfunction iWin() view public returns (bool) {\nreturn win;\n}\n}\n</code></pre>"},{"location":"docs/SWC-130/","title":"Please note, this content is no longer actively maintained.","text":"<p>The content of the SWC registry has not been thoroughly updated since 2020. It is known to be incomplete and may contain errors as well as crucial omissions.</p> <p>For currently maintained guidance on known Smart Contract vulnerabilities written primarily as guidance for security reviewers, please see the EEA EthTrust Security Levels specification. As well as the latest release version, an Editor's draft is available, that represents the latest work of the group developing the specification.</p> <p>General guidance for developers on what to consider to ensure security, that is currently maintained, is also available through the  Smart Contract Security Verification Standard (SCSVS).</p>"},{"location":"docs/SWC-130/#title","title":"Title","text":"<p>Right-To-Left-Override control character (U+202E)</p>"},{"location":"docs/SWC-130/#relationships","title":"Relationships","text":"<p>CWE-451: User Interface (UI) Misrepresentation of Critical Information</p>"},{"location":"docs/SWC-130/#description","title":"Description","text":"<p>Malicious actors can use the Right-To-Left-Override unicode character to force RTL text rendering and confuse users as to the real intent of a contract.</p>"},{"location":"docs/SWC-130/#remediation","title":"Remediation","text":"<p>There are very few legitimate uses of the U+202E character. It should not appear in the source code of a smart contract.</p>"},{"location":"docs/SWC-130/#references","title":"References","text":"<ul> <li>Outsmarting Smart Contracts</li> </ul> <p>EEA EthTrust Security Levels specification:</p> <ul> <li>[S] No Unicode Direction Control Characters</li> <li>[M] No Unnecessary Unicode Controls</li> <li>[M] No Homoglyph-style Attack</li> </ul>"},{"location":"docs/SWC-130/#samples","title":"Samples","text":""},{"location":"docs/SWC-130/#guess_the_numbersol","title":"guess_the_number.sol","text":"<pre><code>/*\n * @source: https://youtu.be/P_Mtd5Fc_3E\n * @author: Shahar Zini\n */\npragma solidity ^0.5.0;\n\ncontract GuessTheNumber\n{\nuint _secretNumber;\naddress payable _owner;\nevent success(string);\nevent wrongNumber(string);\n\nconstructor(uint secretNumber) payable public\n{\nrequire(secretNumber &lt;= 10);\n_secretNumber = secretNumber;\n_owner = msg.sender;\n}\n\nfunction getValue() view public returns (uint)\n{\nreturn address(this).balance;\n}\n\nfunction guess(uint n) payable public\n{\nrequire(msg.value == 1 ether);\n\nuint p = address(this).balance;\ncheckAndTransferPrize(/*The prize\u202e/*rebmun desseug*/n , p/*\u202d\n                /*The user who should benefit */,msg.sender);\n}\n\nfunction checkAndTransferPrize(uint p, uint n, address payable guesser) internal returns(bool)\n{\nif(n == _secretNumber)\n{\nguesser.transfer(p);\nemit success(\"You guessed the correct number!\");\n}\nelse\n{\nemit wrongNumber(\"You've made an incorrect guess!\");\n}\n}\n\nfunction kill() public\n{\nrequire(msg.sender == _owner);\nselfdestruct(_owner);\n}\n}\n</code></pre>"},{"location":"docs/SWC-130/#comments","title":"Comments","text":"<p>The line</p> <pre><code>checkAndTransferPrize(/*The prize\u202e/*rebmun desseug*/n , p/*\n</code></pre> <p>inside the function <code>guess(uint n)</code> uses invisible direction control characters, so what is present on the screen misrepresents the order of the parameters - the function is called with parameters <code>n, p, address</code>, which is the logical order of characters, but some are displayed from right to left, so that the segment 'n, p' appears in reverse order to a reader,  because invisible direction control characters are included in the code.</p> <p>Selecting the text character by character will usually show this - the selection suddenly jumps to the end of the right-to-left text, and starts to extend from the right hand side leftward. It is also possible to check for the unicode characters explicitly in the content.</p>"},{"location":"docs/SWC-131/","title":"Title","text":"<p>Presence of unused variables</p>"},{"location":"docs/SWC-131/#relationships","title":"Relationships","text":"<p>CWE-1164: Irrelevant Code</p>"},{"location":"docs/SWC-131/#description","title":"Description","text":"<p>Unused variables are allowed in Solidity and they do not pose a direct security issue. It is best practice though to avoid them as they can:</p> <ul> <li>cause an increase in computations (and unnecessary gas consumption)</li> <li>indicate bugs or malformed data structures and they are generally a sign of poor code quality</li> <li>cause code noise and decrease readability of the code</li> </ul>"},{"location":"docs/SWC-131/#remediation","title":"Remediation","text":"<p>Remove all unused variables from the code base.</p>"},{"location":"docs/SWC-131/#references","title":"References","text":"<ul> <li>Unused local variables warnings discussion</li> <li>Shadowing of inherited state variables discussion</li> </ul>"},{"location":"docs/SWC-131/#samples","title":"Samples","text":""},{"location":"docs/SWC-131/#unused_state_variablessol","title":"unused_state_variables.sol","text":"<pre><code>pragma solidity &gt;=0.5.0;\npragma experimental ABIEncoderV2;\n\nimport \"./base.sol\";\n\ncontract DerivedA is Base {\n// i is not used in the current contract\nA i = A(1);\n\nint internal j = 500;\n\nfunction call(int a) public {\nassign1(a);\n}\n\nfunction assign3(A memory x) public returns (uint) {\nreturn g[1] + x.a + uint(j);\n}\n\nfunction ret() public returns (int){\nreturn this.e();\n\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-131/#unused_state_variables_fixedsol","title":"unused_state_variables_fixed.sol","text":"<pre><code>pragma solidity &gt;=0.5.0;\npragma experimental ABIEncoderV2;\n\nimport \"./base_fixed.sol\";\n\ncontract DerivedA is Base {\n\nint internal j = 500;\n\nfunction call(int a) public {\nassign1(a);\n}\n\nfunction assign3(A memory x) public returns (uint) {\nreturn g[1] + x.a + uint(j);\n}\n\nfunction ret() public returns (int){\nreturn this.e();\n\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-131/#unused_variablessol","title":"unused_variables.sol","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract UnusedVariables {\nint a = 1;\n\n// y is not used\nfunction unusedArg(int x, int y) public view returns (int z) {\nz = x + a;  }\n\n// n is not reported it is part of another SWC category\nfunction unusedReturn(int x, int y) public pure returns (int m, int n, int o) {\nm = y - x;\no = m/2;\n}\n\n// x is not accessed \nfunction neverAccessed(int test) public pure returns (int) {\nint z = 10;\n\nif (test &gt; z) {\n// x is not used\nint x = test - z;\n\nreturn test - z;\n}\n\nreturn z;\n}\n\nfunction tupleAssignment(int p) public returns (int q, int r){\n(q, , r) = unusedReturn(p,2);\n\n}\n\n\n}\n</code></pre>"},{"location":"docs/SWC-131/#unused_variables_fixedsol","title":"unused_variables_fixed.sol","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract UnusedVariables {\nint a = 1;\n\nfunction unusedArg(int x) public view returns (int z) {\nz = x + a;  }\n\n// n is not reported it is part of another SWC category\nfunction unusedReturn(int x, int y) public pure returns (int m, int n,int o) {\nm = y - x;\no = m/2;\n}\n\n// x is not accessed \nfunction neverAccessed(int test) public pure returns (int) {\nint z = 10;\n\nif (test &gt; z) {\nreturn test - z;\n}\n\nreturn z;\n}\n\nfunction tupleAssignment(int p) public returns (int q, int r){\n(q, , r) = unusedReturn(p,2);\n\n}\n\n}\n</code></pre>"},{"location":"docs/SWC-132/","title":"Title","text":"<p>Unexpected Ether balance</p>"},{"location":"docs/SWC-132/#relationships","title":"Relationships","text":"<p>CWE-667: Improper Locking</p>"},{"location":"docs/SWC-132/#description","title":"Description","text":"<p>Contracts can behave erroneously when they strictly assume a specific Ether balance. It is always possible to forcibly send ether to a contract (without triggering its fallback function), using selfdestruct, or by mining to the account. In the worst case scenario this could lead to DOS conditions that might render the contract unusable.</p>"},{"location":"docs/SWC-132/#remediation","title":"Remediation","text":"<p>Avoid strict equality checks for the Ether balance in a contract.</p>"},{"location":"docs/SWC-132/#references","title":"References","text":"<ul> <li>Consensys Best Practices: Force Feeding</li> <li>Sigmaprime: Unexpected Ether</li> <li>Gridlock (a smart contract bug)</li> </ul>"},{"location":"docs/SWC-132/#samples","title":"Samples","text":""},{"location":"docs/SWC-132/#lockdropsol","title":"Lockdrop.sol","text":"<pre><code>/** \n * @source: https://github.com/hicommonwealth/edgeware-lockdrop/blob/93ecb524c9c88d25bab36278541f190fa9e910c2/contracts/Lockdrop.sol\n */\n\npragma solidity ^0.5.0;\n\ncontract Lock {\n// address owner; slot #0\n// address unlockTime; slot #1\nconstructor (address owner, uint256 unlockTime) public payable {\nassembly {\nsstore(0x00, owner)\nsstore(0x01, unlockTime)\n}\n}\n\n/**\n     * @dev        Withdraw function once timestamp has passed unlock time\n     */\nfunction () external payable { // payable so solidity doesn't add unnecessary logic\nassembly {\nswitch gt(timestamp, sload(0x01))\ncase 0 { revert(0, 0) }\ncase 1 {\nswitch call(gas, sload(0x00), balance(address), 0, 0, 0, 0)\ncase 0 { revert(0, 0) }\n}\n}\n}\n}\n\ncontract Lockdrop {\nenum Term {\nThreeMo,\nSixMo,\nTwelveMo\n    }\n// Time constants\nuint256 constant public LOCK_DROP_PERIOD = 1 days * 92; // 3 months\nuint256 public LOCK_START_TIME;\nuint256 public LOCK_END_TIME;\n// ETH locking events\nevent Locked(address indexed owner, uint256 eth, Lock lockAddr, Term term, bytes edgewareAddr, bool isValidator, uint time);\nevent Signaled(address indexed contractAddr, bytes edgewareAddr, uint time);\n\nconstructor(uint startTime) public {\nLOCK_START_TIME = startTime;\nLOCK_END_TIME = startTime + LOCK_DROP_PERIOD;\n}\n\n/**\n     * @dev        Locks up the value sent to contract in a new Lock\n     * @param      term         The length of the lock up\n     * @param      edgewareAddr The bytes representation of the target edgeware key\n     * @param      isValidator  Indicates if sender wishes to be a validator\n     */\nfunction lock(Term term, bytes calldata edgewareAddr, bool isValidator)\nexternal\npayable\ndidStart\n        didNotEnd\n    {\nuint256 eth = msg.value;\naddress owner = msg.sender;\nuint256 unlockTime = unlockTimeForTerm(term);\n// Create ETH lock contract\nLock lockAddr = (new Lock).value(eth)(owner, unlockTime);\n// ensure lock contract has all ETH, or fail\nassert(address(lockAddr).balance == msg.value);\nemit Locked(owner, eth, lockAddr, term, edgewareAddr, isValidator, now);\n}\n\n/**\n     * @dev        Signals a contract's (or address's) balance decided after lock period\n     * @param      contractAddr  The contract address from which to signal the balance of\n     * @param      nonce         The transaction nonce of the creator of the contract\n     * @param      edgewareAddr   The bytes representation of the target edgeware key\n     */\nfunction signal(address contractAddr, uint32 nonce, bytes calldata edgewareAddr)\nexternal\ndidStart\n        didNotEnd\n        didCreate(contractAddr, msg.sender, nonce)\n{\nemit Signaled(contractAddr, edgewareAddr, now);\n}\n\nfunction unlockTimeForTerm(Term term) internal view returns (uint256) {\nif (term == Term.ThreeMo) return now + 92 days;\nif (term == Term.SixMo) return now + 183 days;\nif (term == Term.TwelveMo) return now + 365 days;\n\nrevert();\n}\n\n/**\n     * @dev        Ensures the lockdrop has started\n     */\nmodifier didStart() {\nrequire(now &gt;= LOCK_START_TIME);\n_;\n}\n\n/**\n     * @dev        Ensures the lockdrop has not ended\n     */\nmodifier didNotEnd() {\nrequire(now &lt;= LOCK_END_TIME);\n_;\n}\n\n/**\n     * @dev        Rebuilds the contract address from a normal address and transaction nonce\n     * @param      _origin  The non-contract address derived from a user's public key\n     * @param      _nonce   The transaction nonce from which to generate a contract address\n     */\nfunction addressFrom(address _origin, uint32 _nonce) public pure returns (address) {\nif(_nonce == 0x00)     return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd6), byte(0x94), _origin, byte(0x80))))));\nif(_nonce &lt;= 0x7f)     return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd6), byte(0x94), _origin, uint8(_nonce))))));\nif(_nonce &lt;= 0xff)     return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd7), byte(0x94), _origin, byte(0x81), uint8(_nonce))))));\nif(_nonce &lt;= 0xffff)   return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd8), byte(0x94), _origin, byte(0x82), uint16(_nonce))))));\nif(_nonce &lt;= 0xffffff) return address(uint160(uint256(keccak256(abi.encodePacked(byte(0xd9), byte(0x94), _origin, byte(0x83), uint24(_nonce))))));\nreturn address(uint160(uint256(keccak256(abi.encodePacked(byte(0xda), byte(0x94), _origin, byte(0x84), uint32(_nonce)))))); // more than 2^32 nonces not realistic\n}\n\n/**\n     * @dev        Ensures the target address was created by a parent at some nonce\n     * @param      target  The target contract address (or trivially the parent)\n     * @param      parent  The creator of the alleged contract address\n     * @param      nonce   The creator's tx nonce at the time of the contract creation\n     */\nmodifier didCreate(address target, address parent, uint32 nonce) {\n// Trivially let senders \"create\" themselves\nif (target == parent) {\n_;\n} else {\nrequire(target == addressFrom(parent, nonce));\n_;\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-133/","title":"Title","text":"<p>Hash Collisions With Multiple Variable Length Arguments</p>"},{"location":"docs/SWC-133/#relationships","title":"Relationships","text":"<p>CWE-294: Authentication Bypass by Capture-replay</p>"},{"location":"docs/SWC-133/#description","title":"Description","text":"<p>Using <code>abi.encodePacked()</code> with multiple variable length arguments can, in certain situations, lead to a hash collision. Since <code>abi.encodePacked()</code> packs all elements in order regardless of whether they're part of an array, you can move elements between arrays and, so long as all elements are in the same order, it will return the same encoding. In a signature verification situation, an attacker could exploit this by modifying the position of elements in a previous function call to effectively bypass authorization.</p>"},{"location":"docs/SWC-133/#remediation","title":"Remediation","text":"<p>When using <code>abi.encodePacked()</code>, it's crucial to ensure that a matching signature cannot be achieved using different parameters. To do so, either do not allow users access to parameters used in <code>abi.encodePacked()</code>, or use fixed length arrays. Alternatively, you can simply use <code>abi.encode()</code> instead.</p> <p>It is also recommended that you use replay protection (see SWC-121), although an attacker can still bypass this by front-running.</p>"},{"location":"docs/SWC-133/#references","title":"References","text":"<ul> <li>Solidity Non-standard Packed Mode</li> <li>Hash Collision Attack</li> </ul>"},{"location":"docs/SWC-133/#samples","title":"Samples","text":""},{"location":"docs/SWC-133/#access_controlsol","title":"access_control.sol","text":"<pre><code>/*\n * @author: Steve Marx\n */\n\npragma solidity ^0.5.0;\n\nimport \"./ECDSA.sol\";\n\ncontract AccessControl {\nusing ECDSA for bytes32;\nmapping(address =&gt; bool) isAdmin;\nmapping(address =&gt; bool) isRegularUser;\n// Add admins and regular users.\nfunction addUsers(\naddress[] calldata admins,\naddress[] calldata regularUsers,\nbytes calldata signature\n    )\nexternal\n{\nif (!isAdmin[msg.sender]) {\n// Allow calls to be relayed with an admin's signature.\nbytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));\naddress signer = hash.toEthSignedMessageHash().recover(signature);\nrequire(isAdmin[signer], \"Only admins can add users.\");\n}\nfor (uint256 i = 0; i &lt; admins.length; i++) {\nisAdmin[admins[i]] = true;\n}\nfor (uint256 i = 0; i &lt; regularUsers.length; i++) {\nisRegularUser[regularUsers[i]] = true;\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-133/#access_control_fixed_1sol","title":"access_control_fixed_1.sol","text":"<pre><code>/*\n * @author: Steve Marx\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\nimport \"./ECDSA.sol\";\n\ncontract AccessControl {\nusing ECDSA for bytes32;\nmapping(address =&gt; bool) isAdmin;\nmapping(address =&gt; bool) isRegularUser;\n// Add a single user, either an admin or regular user.\nfunction addUser(\naddress user,\nbool admin,\nbytes calldata signature\n    )\nexternal\n{\nif (!isAdmin[msg.sender]) {\n// Allow calls to be relayed with an admin's signature.\nbytes32 hash = keccak256(abi.encodePacked(user));\naddress signer = hash.toEthSignedMessageHash().recover(signature);\nrequire(isAdmin[signer], \"Only admins can add users.\");\n}\nif (admin) {\nisAdmin[user] = true;\n} else {\nisRegularUser[user] = true;\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-133/#access_control_fixed_2sol","title":"access_control_fixed_2.sol","text":"<pre><code>/*\n * @author: Steve Marx\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\nimport \"./ECDSA.sol\";\n\ncontract AccessControl {\nusing ECDSA for bytes32;\nmapping(address =&gt; bool) isAdmin;\nmapping(address =&gt; bool) isRegularUser;\n// Add admins and regular users.\nfunction addUsers(\n// Use fixed length arrays.\naddress[3] calldata admins,\naddress[3] calldata regularUsers,\nbytes calldata signature\n    )\nexternal\n{\nif (!isAdmin[msg.sender]) {\n// Allow calls to be relayed with an admin's signature.\nbytes32 hash = keccak256(abi.encodePacked(admins, regularUsers));\naddress signer = hash.toEthSignedMessageHash().recover(signature);\nrequire(isAdmin[signer], \"Only admins can add users.\");\n}\nfor (uint256 i = 0; i &lt; admins.length; i++) {\nisAdmin[admins[i]] = true;\n}\nfor (uint256 i = 0; i &lt; regularUsers.length; i++) {\nisRegularUser[regularUsers[i]] = true;\n}\n}\n}\n</code></pre>"},{"location":"docs/SWC-134/","title":"Title","text":"<p>Message call with hardcoded gas amount</p>"},{"location":"docs/SWC-134/#relationships","title":"Relationships","text":"<p>CWE-655: Improper Initialization</p>"},{"location":"docs/SWC-134/#description","title":"Description","text":"<p>The <code>transfer()</code> and <code>send()</code> functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs.  For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction.</p>"},{"location":"docs/SWC-134/#remediation","title":"Remediation","text":"<p>Avoid the use of <code>transfer()</code> and <code>send()</code> and do not otherwise specify a fixed amount of gas when performing calls. Use <code>.call.value(...)(\"\")</code> instead. Use the checks-effects-interactions pattern and/or reentrancy locks to prevent reentrancy attacks.</p>"},{"location":"docs/SWC-134/#references","title":"References","text":"<ul> <li>ChainSecurity - Ethereum Istanbul Hardfork: The Security Perspective</li> <li>Steve Marx - Stop Using Solidity\u2019s transfer() Now   </li> <li>EIP 1884</li> </ul>"},{"location":"docs/SWC-134/#samples","title":"Samples","text":""},{"location":"docs/SWC-134/#hardcoded_gas_limitssol","title":"hardcoded_gas_limits.sol","text":"<pre><code>/*\n * @author: Bernhard Mueller (ConsenSys / MythX)\n */\n\npragma solidity 0.6.4;\n\ninterface ICallable {\nfunction callMe() external;\n}\n\ncontract HardcodedNotGood {\n\naddress payable _callable = 0xaAaAaAaaAaAaAaaAaAAAAAAAAaaaAaAaAaaAaaAa;\nICallable callable = ICallable(_callable);\n\nconstructor() public payable {\n}\n\nfunction doTransfer(uint256 amount) public {\n_callable.transfer(amount);\n}\n\nfunction doSend(uint256 amount) public {\n_callable.send(amount);\n}\n\nfunction callLowLevel() public {\n_callable.call.value(0).gas(10000)(\"\");\n}\n\nfunction callWithArgs() public {\ncallable.callMe{gas: 10000}();\n}\n}\n</code></pre>"},{"location":"docs/SWC-135/","title":"Title","text":"<p>Code With No Effects</p>"},{"location":"docs/SWC-135/#relationships","title":"Relationships","text":"<p>CWE-1164: Irrelevant Code</p>"},{"location":"docs/SWC-135/#description","title":"Description","text":"<p>In Solidity, it's possible to write code that does not produce the intended effects. Currently, the solidity compiler will not return a warning for effect-free code. This can lead to the introduction of \"dead\" code that does not properly perform an intended action.</p> <p>For example, it's easy to miss the trailing parentheses in <code>msg.sender.call.value(address(this).balance)(\"\");</code>, which could lead to a function proceeding without transferring funds to <code>msg.sender</code>. Although, this should be avoided by checking the return value of the call.</p>"},{"location":"docs/SWC-135/#remediation","title":"Remediation","text":"<p>It's important to carefully ensure that your contract works as intended. Write  unit tests to verify correct behaviour of the code.</p>"},{"location":"docs/SWC-135/#references","title":"References","text":"<ul> <li>Issue on Solidity's Github - raise an error when a statement can never have side-effects</li> <li>Issue on Solidity's Github - msg.sender.call.value(address(this).balance); should produce a warning</li> </ul>"},{"location":"docs/SWC-135/#samples","title":"Samples","text":""},{"location":"docs/SWC-135/#deposit_boxsol","title":"deposit_box.sol","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract DepositBox {\nmapping(address =&gt; uint) balance;\n\n// Accept deposit\nfunction deposit(uint amount) public payable {\nrequire(msg.value == amount, 'incorrect amount');\n// Should update user balance\nbalance[msg.sender] == amount;\n}\n}\n</code></pre>"},{"location":"docs/SWC-135/#deposit_box_fixedsol","title":"deposit_box_fixed.sol","text":"<pre><code>pragma solidity ^0.5.0;\n\ncontract DepositBox {\nmapping(address =&gt; uint) balance;\n\n// Accept deposit\nfunction deposit(uint amount) public payable {\nrequire(msg.value == amount, 'incorrect amount');\n// Should update user balance\nbalance[msg.sender] = amount;\n}\n}\n</code></pre>"},{"location":"docs/SWC-135/#walletsol","title":"wallet.sol","text":"<pre><code>/*\n * @author: Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract Wallet {\nmapping(address =&gt; uint) balance;\n\n// Deposit funds in contract\nfunction deposit(uint amount) public payable {\nrequire(msg.value == amount, 'msg.value must be equal to amount');\nbalance[msg.sender] = amount;\n}\n\n// Withdraw funds from contract\nfunction withdraw(uint amount) public {\nrequire(amount &lt;= balance[msg.sender], 'amount must be less than balance');\n\nuint previousBalance = balance[msg.sender];\nbalance[msg.sender] = previousBalance - amount;\n\n// Attempt to send amount from the contract to msg.sender\nmsg.sender.call.value(amount);\n}\n}\n</code></pre>"},{"location":"docs/SWC-135/#wallet_fixedsol","title":"wallet_fixed.sol","text":"<pre><code>/*\n * @author: Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract Wallet {\nmapping(address =&gt; uint) balance;\n\n// Deposit funds in contract\nfunction deposit(uint amount) public payable {\nrequire(msg.value == amount, 'msg.value must be equal to amount');\nbalance[msg.sender] = amount;\n}\n\n// Withdraw funds from contract\nfunction withdraw(uint amount) public {\nrequire(amount &lt;= balance[msg.sender], 'amount must be less than balance');\n\nuint previousBalance = balance[msg.sender];\nbalance[msg.sender] = previousBalance - amount;\n\n// Attempt to send amount from the contract to msg.sender\n(bool success, ) = msg.sender.call.value(amount)(\"\");\nrequire(success, 'transfer failed');\n}\n}\n</code></pre>"},{"location":"docs/SWC-136/","title":"Please note, this content is no longer actively maintained.","text":"<p>The content of the SWC registry has not been thoroughly updated since 2020. It is known to be incomplete and may contain errors as well as crucial omissions.</p> <p>For currently maintained guidance on known Smart Contract vulnerabilities written primarily as guidance for security reviewers, please see the EEA EthTrust Security Levels specification. As well as the latest release version, an Editor's draft is available,  that represents the latest work of the group developing the specification.</p> <p>General guidance for developers on what to consider to ensure security, that is currently maintained, is also available through the  Smart Contract Security Verification Standard (SCSVS).</p>"},{"location":"docs/SWC-136/#title","title":"Title","text":"<p>Unencrypted Private Data On-Chain</p>"},{"location":"docs/SWC-136/#relationships","title":"Relationships","text":"<p>CWE-767: Access to Critical Private Variable via Public Method</p>"},{"location":"docs/SWC-136/#description","title":"Description","text":"<p>It is a common misconception that <code>private</code> type variables cannot be read. Even if your contract is not published, attackers can look at contract transactions to determine values stored in the state of the contract. For this reason, it's important that unencrypted private data is not stored in the contract code or state.</p>"},{"location":"docs/SWC-136/#remediation","title":"Remediation","text":"<p>Any private data should either be stored off-chain, or carefully encrypted.</p>"},{"location":"docs/SWC-136/#references","title":"References","text":"<ul> <li>Keeping secrets on Ethereum</li> <li>A Survey of Attacks on Ethereum Smart Contracts (SoK)</li> <li>Unencrypted Secrets</li> <li>Stack Overflow - Decrypt message on-chain</li> </ul>"},{"location":"docs/SWC-136/#samples","title":"Samples","text":""},{"location":"docs/SWC-136/#odd_evensol","title":"odd_even.sol","text":"<pre><code>/*\n * @source: https://gist.github.com/manojpramesh/336882804402bee8d6b99bea453caadd#file-odd-even-sol\n * @author: https://github.com/manojpramesh\n * Modified by Kaden Zipfel\n */\n\npragma solidity ^0.5.0;\n\ncontract OddEven {\nstruct Player {\naddress addr;\nuint number;\n}\n\nPlayer[2] private players;\nuint count = 0;\n\nfunction play(uint number) public payable {\nrequire(msg.value == 1 ether, 'msg.value must be 1 eth');\nplayers[count] = Player(msg.sender, number);\ncount++;\nif (count == 2) selectWinner();\n}\n\nfunction selectWinner() private {\nuint n = players[0].number + players[1].number;\n(bool success, ) = players[n%2].addr.call.value(address(this).balance)(\"\");\nrequire(success, 'transfer failed');\ndelete players;\ncount = 0;\n}\n}\n</code></pre>"},{"location":"docs/SWC-136/#comments","title":"Comments","text":"<p>The vulnerable version above requires the players to send the number they are using as part of the transaction. This means the first player's number will be visible, allowing the second player to select a number that they know will make them a winner. (This assumption is simplistic to illustrate - there are also possibilities to front-run players, among other potential issues).</p> <p>In the fixed version below, the players instead submit a commitment that obfuscates their number, and only subsequently reveal that they know the secret to set in train the process of a payout.</p>"},{"location":"docs/SWC-136/#odd_even_fixedsol","title":"odd_even_fixed.sol","text":"<pre><code>/*\n * @source: https://github.com/yahgwai/rps\n * @author: Chris Buckland\n * Modified by Kaden Zipfel\n * Modified by Kacper \u017buk\n */\n\npragma solidity ^0.5.0;\n\ncontract OddEven {\nenum Stage {\nFirstCommit,\nSecondCommit,\nFirstReveal,\nSecondReveal,\nDistribution\n    }\n\nstruct Player {\naddress addr;\nbytes32 commitment;\nbool revealed;\nuint number;\n}\n\nPlayer[2] private players;\nStage public stage = Stage.FirstCommit;\n\nfunction play(bytes32 commitment) public payable {\n// Only run during commit stages\nuint playerIndex;\nif(stage == Stage.FirstCommit) playerIndex = 0;\nelse if(stage == Stage.SecondCommit) playerIndex = 1;\nelse revert(\"only two players allowed\");\n\n// Require proper amount deposited\n// 1 ETH as a bet + 1 ETH as a bond\nrequire(msg.value == 2 ether, 'msg.value must be 2 eth');\n\n// Store the commitment\nplayers[playerIndex] = Player(msg.sender, commitment, false, 0);\n\n// Move to next stage\nif(stage == Stage.FirstCommit) stage = Stage.SecondCommit;\nelse stage = Stage.FirstReveal;\n}\n\nfunction reveal(uint number, bytes32 blindingFactor) public {\n// Only run during reveal stages\nrequire(stage == Stage.FirstReveal || stage == Stage.SecondReveal, \"wrong stage\");\n\n// Find the player index\nuint playerIndex;\nif(players[0].addr == msg.sender) playerIndex = 0;\nelse if(players[1].addr == msg.sender) playerIndex = 1;\nelse revert(\"unknown player\");\n\n// Protect against double-reveal, which would trigger move to Stage.Distribution too early\nrequire(!players[playerIndex].revealed, \"already revealed\");\n\n// Check the hash to prove the player's honesty\nrequire(keccak256(abi.encodePacked(msg.sender, number, blindingFactor)) == players[playerIndex].commitment, \"invalid hash\");\n\n// Update player number if correct\nplayers[playerIndex].number = number;\n\n// Protect against double-reveal\nplayers[playerIndex].revealed = true;\n\n// Move to next stage\nif(stage == Stage.FirstReveal) stage = Stage.SecondReveal;\nelse stage = Stage.Distribution;\n}\n\nfunction distribute() public {\n// Only run during distribution stage\nrequire(stage == Stage.Distribution, \"wrong stage\");\n\n// Find winner\nuint n = players[0].number + players[1].number;\n\n// Payout winners winnings and bond\nplayers[n%2].addr.call.value(3 ether)(\"\");\n\n// Payback losers bond\nplayers[(n+1)%2].addr.call.value(1 ether)(\"\");\n\n// Reset the state\ndelete players;\nstage = Stage.FirstCommit;\n}\n}\n</code></pre>"}]}